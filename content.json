{"meta":{"title":"哦谢特谢特","subtitle":"苟利国家生死以","description":null,"author":"哦谢特谢特","url":"http://yoursite.com"},"pages":[{"title":"Linux","date":"2018-06-21T07:46:09.000Z","updated":"2018-06-21T07:46:09.000Z","comments":true,"path":"Linux/index.html","permalink":"http://yoursite.com/Linux/index.html","excerpt":"","text":""},{"title":"Favorite","date":"2018-06-23T15:00:44.000Z","updated":"2018-06-26T13:24:08.000Z","comments":true,"path":"favorite/index.html","permalink":"http://yoursite.com/favorite/index.html","excerpt":"","text":"也许你听说过，「业余时间决定人生」；也许你还听说过，「听过很多道理，依然过不好这一生」。书籍、代码、博客、运动、电影、动漫、游戏，这就是我的业余生活。 我的能力就这么多。我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 趁我在还能写得动代码看得进书的年纪，努力一回，看看这平庸的资质究竟能发挥几分.hexo-image-steam-lazy {display:block;}.hexo-img-stream{width:90%;max-width:1100px;margin:3% auto}div.hexo-img-stream figure{background:#fefefe;box-shadow:0 1px 2px rgba(34,25,25,0.4);margin:0 0.05% 3%;padding:3%;padding-bottom:10px;display:inline-block;max-width:25%}div.hexo-img-stream figure img{border-bottom:1px solid #ccc;padding-bottom:15px;margin-bottom:5px}div.hexo-img-stream figure figcaption{font-size:.9rem;color:#444;line-height:1.5;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}div.hexo-img-stream small{font-size:1rem;float:right;text-transform:uppercase;color:#aaa}div.hexo-img-stream small a{color:#666;text-decoration:none;transition:.4s color}@media screen and (max-width:750px){.hexo-img-stream{column-gap:0}}Docker进阶与实战 命运石之门0 STEINS;GATE 0 超人总动员 亿级流量网站架构核心技术 Redis设计与实现 宅男腐女恋爱真难 DARLING in the FRANXX $('img.hexo-image-steam-lazy').lazyload({ effect:'fadeIn' });"}],"posts":[{"title":"欢迎来到我的Lab，助手呦！","slug":"hello-world","date":"2022-11-06T07:47:44.000Z","updated":"2018-06-24T15:38:38.000Z","comments":true,"path":"2022/11/06/hello-world/","link":"","permalink":"http://yoursite.com/2022/11/06/hello-world/","excerpt":"","text":"最近刚刚搭建了我的个人博客，准备把之前博客的文章慢慢迁移过来，我会看心情发一些学习和日常，还有推荐一些好看的动漫，有时会发一些小福利，做一些彩蛋什么的，希望大家常来玩！ el psy congroo","categories":[],"tags":[]},{"title":"网络工程期末考试 （答案整理：大哥）","slug":"20180701-游戏开发技术","date":"2018-07-01T07:47:44.000Z","updated":"2018-07-05T05:02:19.000Z","comments":true,"path":"2018/07/01/20180701-游戏开发技术/","link":"","permalink":"http://yoursite.com/2018/07/01/20180701-游戏开发技术/","excerpt":"游戏开发技术（试题构成：8个问答，1个设计题） 1. 什么是Unity3D？定义:Unity3D是由UnityTechnologies开发的一个让玩家轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合性游戏开发工具，是一个全面整合的专业游戏引擎。特点：开发简单、高度封装、跨平台、费用便宜。 2. 什么是游戏引擎？它分为几类，常用的是哪几类？定义：游戏引擎是指一些已编写好的可编辑电脑游戏系统或者一些交互式实时图像应用程序的核心组件。分类：按开发游戏的维度：2D引擎、3D引擎 按引擎使用是否收费：开源引擎、商业引擎常用游戏引擎：AndEngine、Cocos2d-x、OGRE、RAGE、CryEngine、UnrealEngine、Unity3D","text":"游戏开发技术（试题构成：8个问答，1个设计题） 1. 什么是Unity3D？定义:Unity3D是由UnityTechnologies开发的一个让玩家轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合性游戏开发工具，是一个全面整合的专业游戏引擎。特点：开发简单、高度封装、跨平台、费用便宜。 2. 什么是游戏引擎？它分为几类，常用的是哪几类？定义：游戏引擎是指一些已编写好的可编辑电脑游戏系统或者一些交互式实时图像应用程序的核心组件。分类：按开发游戏的维度：2D引擎、3D引擎 按引擎使用是否收费：开源引擎、商业引擎常用游戏引擎：AndEngine、Cocos2d-x、OGRE、RAGE、CryEngine、UnrealEngine、Unity3D 3. 计算机动画的概念，合成计算机动画的技术？计算机动画：采用图形图像处理技术，借助于编程或动画制作软件生成一系列动态连续图像。常见计算机动画技术： 1）基本动画技术：逐帧动画（将组成动画所需的一系列画面存放在不同的帧中，一帧一帧顺序播放）；关键帧动画（动画师从连续动作的画面中，选出少数几帧画面作为关键帧，在关键帧的基础上，使用计算机自动生成期望帧序列） 2）脚本驱动的动画技术：指定人物如何运动；指定场景与人物的交互方式；控制具体的运动任务（规划动画人物的运动路径；运动过程避开障碍；动画人物的运动协调） 3）骨骼动画技术：与人体运动方式类似，把角色各部分身体部件图片绑定到互相连接作用的“骨头”上，通过“骨骼” 的位置变化而生成动画；只需少量图片资源，骨骼动画数据保存在Json文件中，占用空间小。 4. 常见的碰撞检测的的方法？ 碰撞检测常见的方法：1）区域检测：①规则形状检测（矩形或圆形）： 检测方法：将被检测物体置于某种规则形状之中进行判断：【矩形：通过比较各自的左上角和右下角的坐标来实现检测】；【圆形：通过圆心距与各自半径的关系来检测】优点:检测方式速度快缺点：精度不高，可能出现两物体还未碰撞就误判的情况（解决方案：可以对一个物体设定多个检测区域，尽量使检测区域的外形与物体轮廓接近） ②基于碰撞点检测： 检测方法：在两个运动物体中的一个物体上设置碰撞点，在另一个物体上设置检测区域。游戏运行时逐个判断碰撞点是否在检测区域中。 优点：较为精确的检测方式 缺点：相对耗时2）碰撞点检测：基于碰撞点检测： 检测方法：在两个运动物体中的一个物体上设置碰撞点，在另一个物体上设置检测区域。游戏运行时逐个判断碰撞点是否在检测区域中。 优点：较为精确的检测方式 缺点：相对耗时 3）颜色检测：基于颜色判断来判断碰撞情况的实现。 5. 什么是交互界面，GUI的概念，如何设计良好的交互界面？用户界面（UI）是人和机器互动过程中的一个重要层面，它是人与机器之间传递和交换信息的媒介游戏中的交互界面设计（GID）：是指对电子游戏中与游戏用户具有交互功能的视觉等实体元素进行规划、布局、导览、切换等，是玩家最直接面对的互动活动，也是玩家对游戏的第一印象。图形用户界面（GUI）：是以视觉感知通道为主的人机界面。 交互界面设计基础：1）色彩设计：优秀的色彩搭配是交互界面设计成功的前提和基础。色彩的三要素：明度、色相、纯度。2）交互界面设计中的问题：①信息的输出：即如何将系统信息和状态明白无误的通知用户②信息输入：即如何提供用户发布正确的输入指令的渠道。（菜单、图标、快捷键）3）游戏软件的交互界面设计的基本原则：①一致性原则 ②提供出错反馈 ③保持界面简洁 ④提供帮助和向导功能 ⑤减少用户得记忆量 6. 粒子系统的概念，作用以及生命周期？1）概念：粒子系统是一系列独立个体的集合，这些独立个体就称为粒子，通常粒子的属性包括位置、速度、加速度、能量、方向等。2）作用：游戏场景中的很多画面效果和物体都可以用粒子系统来模拟，如烟、火焰、爆炸、血溅等。3）生命周期： 7. 什么是声音（计算机角度）？常见的声音引擎？1）声音的本质：50Hz~22000Hz之间的压力波，本质上而言是正弦波，具有波幅和频率等属性。2）常见的声音引擎：BASS（Windows平台下常用的声音引擎，支持多种开发语言）, MikMod, FMOD（支持几乎所有开发平台）, ModPlug, Miles Sound System（快速开发工具，目前最好的音频开发库）,EAX, DOLBY DIGITAL ENCODING（专业的音频开发工具） 8. 游戏的大致分类？每一类游戏的特点？如LOL是由C++、actionScript编写。（1） 角色扮演：这类游戏中所体现的是对整个人生的再现和模拟，所构造的情感世界是能带给我们深刻的体验感。（2） 第一视角射击游戏：FPS是从美国流行起来的一种游戏流派和类型，在融合了迷宫游戏和动作游戏的特点后，引入第一视角和三维图形，使得游戏的表现力得到了极大的提高。（3） 动作类游戏：ACT游戏的乐趣就在于玩家通过不断的训练达到某种技巧上的娴熟，并培养出一定的条件反射（4） 格斗游戏：FTG游戏的基本特征是在一个狭小的场景里，通过复杂的按键序列使双方角色进行一对一的打斗。（5） 回合制策略游戏：在TBS回合制游戏中，玩家和敌方交替采取行动，只有当玩家完成自己的操作后，敌方才能开始考虑对策并实施行动。（6） 实时策略游戏：其中的两个要素是资源管理和狭义的战争策略。（7） 模拟游戏：玩家在游戏中处于领导者的地位，以俯视众生的姿态来看待他所创造的世界和世界中的芸芸众生的活动。（8） 冒险游戏：AVG游戏是以故事、冒险和解迷为要素。（9） 体育类游戏：体育类游戏可以涵盖三个层次：管理、战术和技能（10） 竞速游戏：以比赛的形式，通过模拟各类赛车运动的游戏，拥有自己的地图板块，非常讲究图像音效技术。 9. 如何进行设计一款新游戏？（操作的先后顺序）立项游戏大纲的策划游戏的正式制作配音和配乐检测和测试广告和市场开发生产和发售售后服务","categories":[],"tags":[]},{"title":"Transactional注解讲解","slug":"20180627-TransactionDefinition接口特性","date":"2018-06-27T12:47:44.000Z","updated":"2018-06-28T14:44:34.000Z","comments":true,"path":"2018/06/27/20180627-TransactionDefinition接口特性/","link":"","permalink":"http://yoursite.com/2018/06/27/20180627-TransactionDefinition接口特性/","excerpt":"Transactional注解讲解 在需要事务管理的地方加@Transactional 注解。 @Transactional 注解只能应用到接口方法、类、还有public方法上。","text":"Transactional注解讲解 在需要事务管理的地方加@Transactional 注解。 @Transactional 注解只能应用到接口方法、类、还有public方法上。 12345678910111213 @Override@Transactionalpublic SysUser saveUser(UserDto userDto) &#123; SysUser user = userDto; user.setPassword(passwordEncoder.encode(user.getPassword())); user.setStatus(SysUser.Status.VALID); userDao.save(user); saveUserRoles(user.getId(), userDto.getRoleIds()); log.debug(\"新增用户\", user.getUsername()); return user;&#125; 属性 类型 描述 value String 可选的限定描述符，指定使用的事务管理器 propagation enum: Propagation 可选的事务传播行为设置 isolation enum: Isolation 可选的事务隔离级别设置 readOnly boolean 读写或只读事务，默认读写 timeout int (in seconds granularity) 事务超时时间设置 rollbackFor Class对象数组，必须继承自Throwable 导致事务回滚的异常类数组 rollbackForClassName 类名数组，必须继承自Throwable 导致事务回滚的异常类名字数组 noRollbackFor Class对象数组，必须继承自Throwable 不会导致事务回滚的异常类数组 noRollbackForClassName 类名数组，必须继承自Throwable 不会导致事务回滚的异常类名字数组 TransactionDefinition接口特性：事务隔离级别隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。 TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 事务传播行为所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot jwt redis方式实现登录存储","slug":"20180625-Spring Boot JWT Redis方式实现","date":"2018-06-25T12:47:44.000Z","updated":"2018-06-26T13:07:52.000Z","comments":true,"path":"2018/06/25/20180625-Spring Boot JWT Redis方式实现/","link":"","permalink":"http://yoursite.com/2018/06/25/20180625-Spring Boot JWT Redis方式实现/","excerpt":"Spring Boot jwt redis方式实现登录存储 JWT Redis方式实现1、Token dto","text":"Spring Boot jwt redis方式实现登录存储 JWT Redis方式实现1、Token dto 1234567891011121314151617181920212223242526272829public class Token implements Serializable &#123; private static final long serialVersionUID = 6314027741784310221L; private String token; //登录时间戳 private Long loginTime; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; public Long getLoginTime() &#123; return loginTime; &#125; public void setLoginTime(Long loginTime) &#123; this.loginTime = loginTime; &#125; public Token(String token, Long loginTime) &#123; super(); this.token = token; this.loginTime = loginTime; &#125; 2、LoginUser Dto12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class LoginUser extends SysUser implements UserDetails &#123; private static final long serialVersionUID = -1379274258881257107L; private List&lt;Permission&gt; permissions; private String token; //登录时间戳（毫秒） private Long LoginTime; //过期时间戳 private Long expireTime; public List&lt;Permission&gt; getPermissions() &#123; return permissions; &#125; public void setPermissions(List&lt;Permission&gt; permissions) &#123; this.permissions = permissions; &#125; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; public Long getLoginTime() &#123; return LoginTime; &#125; public void setLoginTime(Long loginTime) &#123; LoginTime = loginTime; &#125; public Long getExpireTime() &#123; return expireTime; &#125; public void setExpireTime(Long expireTime) &#123; this.expireTime = expireTime; &#125; @Override @JsonIgnore //返回的json数据即不包含该属性 public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return permissions.parallelStream().filter(p -&gt; !StringUtils.isEmpty(p.getPermission())) .map(p -&gt; new SimpleGrantedAuthority(p.getPermission())).collect(Collectors.toSet()); &#125; public void setAuthorities(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; // do nothing &#125; /** * 判断账号是否过期 * @return */ @Override @JsonIgnore public boolean isAccountNonExpired() &#123; return true; &#125; /** * 判断账号是否锁定 * @return */ @Override @JsonIgnore public boolean isAccountNonLocked() &#123; return getStatus() != Status.LOCKED; &#125; /** * 判断密码是否过期 * @return */ @Override @JsonIgnore public boolean isCredentialsNonExpired() &#123; return true; &#125; /** * 判断账号是否激活 * @return */ @Override public boolean isEnabled() &#123; return true; &#125; &#125; 3、TokenServiceJwtImpl这里主要是逻辑实现 详细说明一下 jwt的构成【转】原文地址第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)。 header jwt的头部承载两部分信息： 声明类型，这里是jwt 声明加密的算法 通常直接使用 HMAC SHA256 完整的头部就像下面这样的JSON： { “typ”: “JWT”, “alg”: “HS256” } 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 playload 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 标准中注册的声明 公共的声明 私有的声明 标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密. 私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 定义一个payload： { “name”:”Free码农”, “age”:”28”, “org”:”今日头条” } 然后将其进行base64加密，得到Jwt的第二部分： eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9 signature jwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分： 49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY 密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。 具体实现这里我们从配置文件中获取token的过期秒数和私钥。设置一个字符串LOGIN_USER_KEY作为找到登录用户的凭证123456789101112131415//token过期秒数@Value(\"$&#123;token.expire.seconds&#125;\")private Integer expireSeconds;@Autowiredprivate RedisTemplate&lt;String, LoginUser&gt; redisTemplate;@Autowiredprivate SysLogService logService;//私钥@Value(\"$&#123;token.jwtSecret&#125;\")private String jwtSecret;private static Key KEY = null;private static final String LOGIN_USER_KEY = \"LOGIN_USER_KEY\"; 按照上文所说的加密方式进行加密生成token12345678910private String createJWTToken(LoginUser loginUser)&#123; Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(LOGIN_USER_KEY, loginUser.getToken());// 放入一个随机字符串，通过该串可找到登录用户 String jwtToken = Jwts.builder().setClaims(claims).signWith(SignatureAlgorithm.HS256, getKeyInstance()) .compact(); return jwtToken;&#125; 12345678910111213private Key getKeyInstance() &#123; if (KEY == null) &#123; synchronized (TokenServiceJwtImpl.class) &#123; if (KEY == null) &#123;//双重锁 byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(jwtSecret); KEY = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName()); &#125; &#125; &#125; return KEY;&#125; 将登录用户信息储存到redis中123456private void cacheLoginUser(LoginUser loginUser) &#123; loginUser.setLoginTime(System.currentTimeMillis()); loginUser.setExpireTime(loginUser.getLoginTime() + expireSeconds * 1000); //根据uuid将loginUser缓存 redisTemplate.boundValueOps(getTokenKey(loginUser.getToken())).set(loginUser,expireSeconds, TimeUnit.SECONDS);&#125; 之后我们可以根据token从redis获取登录用户的信息，进行判断用户登录是否过期等操作。","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/categories/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"宅男腐女，或许该脱宅了？","slug":"20180624-omaye","date":"2018-06-24T15:47:44.000Z","updated":"2018-06-25T14:14:00.000Z","comments":true,"path":"2018/06/24/20180624-omaye/","link":"","permalink":"http://yoursite.com/2018/06/24/20180624-omaye/","excerpt":"最近喜欢的四月狗粮新番完结了，看完这部番感触也是蛮多。这部番就是宅男腐女恋爱真难。","text":"最近喜欢的四月狗粮新番完结了，看完这部番感触也是蛮多。这部番就是宅男腐女恋爱真难。 相信看过这部番的人都会举报一波标题党，神特么真难=。=，建议改名叫做，宅男腐女恋爱真容易或者宅男腐女恋爱真甜。 这部番看名字像老套的死宅谈恋爱，然而实际上却是超有意思的男女朋友的故事。感觉这种宅男腐女搭配还是蛮有意思的，男主是个宅，死宅，喜欢打游戏，女主是个腐女，喜欢打游戏，以及腐女的喜欢的那些事，属于天然呆型。嘛，不过官方也吐槽过了，只要长得好看宅不宅无所谓的了=。=这种兴趣相投，互相理解，互相欣赏的恋情，我单身狗还能说什么。感觉现实中的宅男腐女还是挺适合谈恋爱的。作为一个单身狗只能羡慕了。 说到这又想到窝自己，还有赫萝老师的一期电台，没错我也是个死宅（相信身边不少人也是这么认为的吧），日常写写代码，看看动漫，打打游戏，最常去的网站是b站。不喜欢出门，单身，也不是没有过喜欢的人，但从来，也没有过然后，不喜欢陌生人，有外人在的时候总是保持沉默。其实本身二次元和三次元本身并不矛盾，现实中应该也有动漫里这样，过着不错的生活，追着喜欢的动漫，在和你一起刷23333的时候，跟女朋友逛街，约会，看电影。感觉能处理好两个世界的东西，是一项非常厉害的技能。不过处理不好的人是怎样的呢，那大概就是本人了=。=。平时会说一些很丧的言论，不过多少身边朋友也会这样，喜欢自厌自嘲，（我差不多是个废人了，我就是个咸鱼），颓废，自我贬低，但我觉得大多数人都有一颗傲娇的灵魂，其实每个人都不是他表现出来的样子，所以人们谈论梦想时，会说些什么呢？也许就会说，我差不多是个废人了。综上所述，这句话的真意又是什么呢？虽然离梦想很遥远，但还是不愿放弃，越是害怕越要面对，所以那些看似很丧的的话语，看似很颓，实则苦涩却又温暖人心。我一直认为，二次元是美好的，有一些作品也对我的生活影响很大，像樱花庄，Clannad，夏目等等。但是这些作品并不是让我感动得泪流满面，然后继续当一个家里蹲，其实死宅真的是浑身充满矛盾的一个群体，沉浸在自己的世界里，逃避现实，在不屑于跟现充一样的同时，又渴望有着现充的生活。不过想想我还能宅多久呢，此处我要说一入宅圈深似海，从此现实是路人！（博主脑残鉴定完毕）在学校，还有那么几个同学可以一起上个厕所什么的，放假了可以在家里窝上一个假期。但是最近学长学姐毕业，和同学一起聊天也不禁会说起毕业的事情，多少会有一些伤感。不管怎么样，无法逃离这个社会是一个不争的事实，社会，它不可能来适应你，也不能逃避一辈子，也许，现在是时候好好考虑一下，如何面对今后的人生了，这也许也是我做这个博客记录自己努力的过程的契机吧。 不过我的业余生活应该还是逃不出写代码，看动漫，看电影，不过今后日常可能会多读读书，写写博客，打打球什么的。 我的能力就这么多。我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸。 那么趁我在还能写得动代码看得进书的年纪，努力一回，看看这平庸的资质究竟能发挥几分。\u0000\u0000\u0000","categories":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/categories/日常/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]},{"title":"Spring Security实现登录功能和原理","slug":"20180623-spring security登录及实现原理","date":"2018-06-23T12:47:44.000Z","updated":"2018-06-26T13:05:41.000Z","comments":true,"path":"2018/06/23/20180623-spring security登录及实现原理/","link":"","permalink":"http://yoursite.com/2018/06/23/20180623-spring security登录及实现原理/","excerpt":"写了几篇前端的东西差点忘了我是个写后台的。。这次我们来讲一下Spring Security实现登录功能和原理（基于springboot+jwt），之前一直会用Spring Security但是对它的认证机制很是懵逼，最近看了源码才豁然开朗。如果需要源码可以留下邮箱。ps：篇幅较长，建议找个舒适的姿势看，不然就会像老夫一样歪着脖子看世界杯到现在还脖子痛。 spring security的配置","text":"写了几篇前端的东西差点忘了我是个写后台的。。这次我们来讲一下Spring Security实现登录功能和原理（基于springboot+jwt），之前一直会用Spring Security但是对它的认证机制很是懵逼，最近看了源码才豁然开朗。如果需要源码可以留下邮箱。ps：篇幅较长，建议找个舒适的姿势看，不然就会像老夫一样歪着脖子看世界杯到现在还脖子痛。 spring security的配置 SecurityConfig 配置文件12345678910111213141516171819202122232425262728@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //跨站请求伪造禁用 http.csrf().disable(); // 基于token，所以不需要session http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); //不需要校验的文件 http.authorizeRequests() .antMatchers(\"/\", \"/*.html\", \"/favicon.ico\", \"/css/**\", \"/js/**\", \"/fonts/**\", \"/layui/**\", \"/img/**\", \"/v2/api-docs/**\", \"/swagger-resources/**\", \"/webjars/**\", \"/pages/**\", \"/druid/**\", \"/statics/**\") .permitAll().anyRequest().authenticated(); http.formLogin().loginPage(\"/login.html\").loginProcessingUrl(\"/login\") .successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler).and() .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint); http.logout().logoutUrl(\"/logout\").logoutSuccessHandler(logoutSuccessHandler); // 解决不允许显示在iframe的问题 http.headers().frameOptions().disable(); http.headers().cacheControl(); http.addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class);&#125;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());&#125; SecurityHandlerConfig（spring security处理器）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 登陆成功，返回token * */@Beanpublic AuthenticationSuccessHandler loginSuccessHandler() &#123; return new AuthenticationSuccessHandler() &#123; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Token token = tokenService.saveToken(loginUser); ResponseUtil.responseJson(httpServletResponse, HttpStatus.OK.value(),token); &#125; &#125;;&#125;/** * 登录失败 */@Beanpublic AuthenticationFailureHandler loginFailureHandler() &#123; return new AuthenticationFailureHandler() &#123; @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; String msg = null; if (e instanceof BadCredentialsException) &#123; msg = \"密码错误\"; &#125; else &#123; msg = e.getMessage(); &#125; ResponseInfo info = new ResponseInfo(HttpStatus.UNAUTHORIZED.value() + \"\", msg); ResponseUtil.responseJson(httpServletResponse, HttpStatus.UNAUTHORIZED.value(), info); &#125; &#125;;&#125;/** * 未登录 */@Beanpublic AuthenticationEntryPoint authenticationEntryPoint() &#123; return new AuthenticationEntryPoint() &#123; @Override public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; ResponseInfo info = new ResponseInfo(HttpStatus.UNAUTHORIZED.value() + \"\", \"请先登录\"); ResponseUtil.responseJson(httpServletResponse, HttpStatus.UNAUTHORIZED.value(), info); &#125; &#125;;&#125;/** * 退出处理 */@Beanpublic LogoutSuccessHandler logoutSuccessHandler() &#123; return new LogoutSuccessHandler() &#123; @Override public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; ResponseInfo info = new ResponseInfo(HttpStatus.OK.value() + \"\", \"退出成功\"); String token = TokenFilter.getToken(httpServletRequest); tokenService.deleteToken(token); ResponseUtil.responseJson(httpServletResponse,HttpStatus.OK.value(),info); &#125; &#125;;&#125; Token拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Componentpublic class TokenFilter extends OncePerRequestFilter &#123; private static final String TOKEN_KEY = \"token\"; private static final Long MINUTES_10 = 10 * 60 * 1000L; @Autowired private TokenService tokenService; @Autowired private UserDetailsService userDetailsService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String token = getToken(request); if (StringUtils.isBlank(token)) &#123; LoginUser loginUser = tokenService.getLoginUser(token); if (loginUser != null) &#123; loginUser = checkLoginTime(loginUser); UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities()); SecurityContextHolder.getContext().setAuthentication(authenticationToken); &#125; &#125; filterChain.doFilter(request,response); &#125; /** * 校验过期时间 * 过期时间与当前时间对比，临近过期10分钟的话，自动刷新缓存 * * @return */ private LoginUser checkLoginTime(LoginUser loginUser) &#123; long expireTime = loginUser.getExpireTime(); long currentTime = System.currentTimeMillis(); if (expireTime - currentTime &lt;= MINUTES_10) &#123; String token = loginUser.getToken(); loginUser = (LoginUser) userDetailsService.loadUserByUsername(loginUser.getUsername()); loginUser.setToken(token); tokenService.refresh(loginUser); &#125; return loginUser; &#125; /** * 根据参数或者header获得token * @param request * @return */ public static String getToken(HttpServletRequest request) &#123; String token = request.getParameter(TOKEN_KEY); if (StringUtils.isBlank(token)) &#123; token = request.getHeader(TOKEN_KEY); &#125; return token; &#125;&#125; 具体实现1、前端调用登录方法123456789101112131415161718192021222324252627function login(obj) &#123; $(obj).attr(\"disabled\", true); var username = $.trim($('#username').val()); var password = $.trim($('#password').val()); if (username == \"\" || password == \"\") &#123; $(\"#info\").html('用户名或者密码不能为空'); $(obj).attr(\"disabled\", false); &#125; else &#123; $.ajax(&#123; type : 'post', url : '/login', data : $(\"#login-form\").serialize(), success : function(data) &#123; localStorage.setItem(\"token\", data.token); location.href = '/index.html'; &#125;, error : function(xhr, textStatus, errorThrown) &#123; var msg = xhr.responseText; var response = JSON.parse(msg); $(\"#info\").html(response.message); $(obj).attr(\"disabled\", false); &#125; &#125;); &#125;&#125; 2、我们在SecurityConfig 配置文件中的这段代码设置了对登录的处理。123http.formLogin().loginPage(\"/login.html\").loginProcessingUrl(\"/login\") .successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler).and() .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint); 3、后经过org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter这个拦截器的attemptAuthentication方法获取到前端的用户名和密码，具体的代码如下123456789101112131415161718192021222324public UsernamePasswordAuthenticationFilter() &#123; super(new AntPathRequestMatcher(\"/login\", \"POST\")); &#125; public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (this.postOnly &amp;&amp; !request.getMethod().equals(\"POST\")) &#123; throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod()); &#125; else &#123; String username = this.obtainUsername(request); String password = this.obtainPassword(request); if (username == null) &#123; username = \"\"; &#125; if (password == null) &#123; password = \"\"; &#125; username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125; &#125; 4、上面的方法只支持post请求，获取到用户名密码后构造未认证的UsernamePasswordAuthentication 后设置details然后通过AuthenticationManager（实际上为ProviderManager的authenticate方法）完成验证，该方法先循环遍历provider 找到具体执行该认证的provider 然后复制details 然后由具体的provider来完成认证，具体代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); AuthenticationException lastException = null; Authentication result = null; boolean debug = logger.isDebugEnabled(); Iterator var6 = this.getProviders().iterator(); while(var6.hasNext()) &#123; AuthenticationProvider provider = (AuthenticationProvider)var6.next(); if (provider.supports(toTest)) &#123; if (debug) &#123; logger.debug(\"Authentication attempt using \" + provider.getClass().getName()); &#125; try &#123; result = provider.authenticate(authentication); if (result != null) &#123; this.copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException var11) &#123; this.prepareException(var11, authentication); throw var11; &#125; catch (InternalAuthenticationServiceException var12) &#123; this.prepareException(var12, authentication); throw var12; &#125; catch (AuthenticationException var13) &#123; lastException = var13; &#125; &#125; &#125; if (result == null &amp;&amp; this.parent != null) &#123; try &#123; result = this.parent.authenticate(authentication); &#125; catch (ProviderNotFoundException var9) &#123; ; &#125; catch (AuthenticationException var10) &#123; lastException = var10; &#125; &#125; if (result != null) &#123; if (this.eraseCredentialsAfterAuthentication &amp;&amp; result instanceof CredentialsContainer) &#123; ((CredentialsContainer)result).eraseCredentials(); &#125; this.eventPublisher.publishAuthenticationSuccess(result); return result; &#125; else &#123; if (lastException == null) &#123; lastException = new ProviderNotFoundException(this.messages.getMessage(\"ProviderManager.providerNotFound\", new Object[]&#123;toTest.getName()&#125;, \"No AuthenticationProvider found for &#123;0&#125;\")); &#125; this.prepareException((AuthenticationException)lastException, authentication); throw lastException; &#125; &#125; 5、 具体的验证处理由DaoAuthenticationProvider的父类AbstractUserDetailsAuthenticationProvider的authenticate方法来完成，该方法先获取到登录的用户名，如果缓存中有UserDetails则从缓存中获取UserDetails如果没有则根据用户名和authentication获取UserDetails 后进行一系列验证成功后返回Authentication，具体代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.onlySupports\", \"Only UsernamePasswordAuthenticationToken is supported\")); String username = authentication.getPrincipal() == null ? \"NONE_PROVIDED\" : authentication.getName(); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); &#125; catch (UsernameNotFoundException var6) &#123; this.logger.debug(\"User '\" + username + \"' not found\"); if (this.hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; throw var6; &#125; Assert.notNull(user, \"retrieveUser returned null - a violation of the interface contract\"); &#125; try &#123; this.preAuthenticationChecks.check(user); this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); &#125; catch (AuthenticationException var7) &#123; if (!cacheWasUsed) &#123; throw var7; &#125; cacheWasUsed = false; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); this.preAuthenticationChecks.check(user); this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); &#125; this.postAuthenticationChecks.check(user); if (!cacheWasUsed) &#123; this.userCache.putUserInCache(user); &#125; Object principalToReturn = user; if (this.forcePrincipalAsString) &#123; principalToReturn = user.getUsername(); &#125; return this.createSuccessAuthentication(principalToReturn, authentication, user); &#125; 6、验证过程由DaoAuthenticationProvider的retrieveUser和additionalAuthenticationChecks方法来实现，具体代码如下12345678910111213141516171819protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; this.prepareTimingAttackProtection(); try &#123; UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); if (loadedUser == null) &#123; throw new InternalAuthenticationServiceException(\"UserDetailsService returned null, which is an interface contract violation\"); &#125; else &#123; return loadedUser; &#125; &#125; catch (UsernameNotFoundException var4) &#123; this.mitigateAgainstTimingAttack(authentication); throw var4; &#125; catch (InternalAuthenticationServiceException var5) &#123; throw var5; &#125; catch (Exception var6) &#123; throw new InternalAuthenticationServiceException(var6.getMessage(), var6); &#125; &#125; 123456789101112protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; if (authentication.getCredentials() == null) &#123; this.logger.debug(\"Authentication failed: no credentials provided\"); throw new BadCredentialsException(this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; else &#123; String presentedPassword = authentication.getCredentials().toString(); if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123; this.logger.debug(\"Authentication failed: password does not match stored value\"); throw new BadCredentialsException(this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; &#125; &#125; 这个方法通过loadUserByUsername来获取到数据库中的用户信息，所以我们要自己重写实现UserDetailsService接口的loadUserByUsername方法，实现如下12345678910111213141516171819202122232425262728293031@Servicepublic class UserDetailsServiceImpl implements UserDetailsService&#123; @Autowired private UserService userService; @Autowired private PermissionDao permissionDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; SysUser user = userService.getUser(username); if (user == null) &#123; throw new AuthenticationCredentialsNotFoundException(\"用户名不存在\"); &#125; else if (user.getStatus() == Status.LOCKED) &#123; throw new LockedException(\"用户被锁定，请联系管理员\"); &#125; else if (user.getStatus() == Status.DISABLED) &#123; throw new DisabledException(\"用户已被封禁\"); &#125; LoginUser loginUser = new LoginUser(); BeanUtils.copyProperties(user, loginUser); List&lt;Permission&gt; permissions = permissionDao.listByUserId(user.getId()); loginUser.setPermissions(permissions); return loginUser; &#125;&#125; 通过loadUserByUsername获取到数据库的用户信息在通过上面的两个方法和前端传过来的用户信息进行比对就完成了登录认证。 认证完成后成功失败等一系列处理在SecurityHandlerConfig进行处理，成功后将token储存到redis中。 可能说的不是很清楚，如果有搞不明白的小伙伴可以来找我一起讨论。最近一直在和老王研究微服务，等上线后我会写一些spring cloud相关的东西。","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/categories/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"网络工程期末考试 （答案整理：胡立阳老哥）","slug":"网络工程期末考试","date":"2018-06-23T07:47:44.000Z","updated":"2018-06-24T02:30:43.000Z","comments":true,"path":"2018/06/23/网络工程期末考试/","link":"","permalink":"http://yoursite.com/2018/06/23/网络工程期末考试/","excerpt":"唉。。。想起来还有期末考试这种东西，算了反正就这一个网络工程。此处感谢胡立阳老哥，还有搬运工龙哥。 一、问答题1、根据《综合布线系统工程设计规范》（GB 50311-2007）标准，并兼顾行业习惯，将综合布线系统划分为哪七个子系统？工作区子系统、建筑群子系统、配线子系统、干线子系统、电信间、设备间、进线间。 此处默念二十遍。 2、下图中展示的综合布线系统哪几个系统，各缩写字母代表什么？CD：建筑群配线设备BD：建筑物配线设备FD：电信间配线设备CP：集合点TO：信息点TE：终端设备","text":"唉。。。想起来还有期末考试这种东西，算了反正就这一个网络工程。此处感谢胡立阳老哥，还有搬运工龙哥。 一、问答题1、根据《综合布线系统工程设计规范》（GB 50311-2007）标准，并兼顾行业习惯，将综合布线系统划分为哪七个子系统？工作区子系统、建筑群子系统、配线子系统、干线子系统、电信间、设备间、进线间。 此处默念二十遍。 2、下图中展示的综合布线系统哪几个系统，各缩写字母代表什么？CD：建筑群配线设备BD：建筑物配线设备FD：电信间配线设备CP：集合点TO：信息点TE：终端设备 3、网络工程建设可简单分为三个阶段，交换机可分为几类？网络规划与设计、工程实施与系统集成、工程竣工验收与技术培训。 （1） 按网络覆盖范围划分：广域网交换机、局域网交换机。 （2） 按照传输介质和数据传输速率划分：以太网交换机、快速以太网交换机、千兆位以太网交换机、万兆位以太网交换机； （3） 按交换机工作的协议层次划分：第二层交换机、第三层交换机、第四层交换机、第七层交换机； （4） 按交换机的端口结构划分：固定式交换机、模块化交换机； （5） 按网络分层结构划分：核心层交换机、汇聚层交换机、接入层交换机； （6） 按外观划分：机箱式交换机、机架式交换机、桌面型交换机； （7） 按交换机应用规模层次划分：企业级交换机、校园网交换机、部门级交换机、工作组交换机； （8） 按是否支持网管功能：网管型和非网管型两大类； （9） 按是否可以堆叠：可堆叠和不可堆叠两大类； 4、交换机中的转发表是如何建立的？ 当交换机接收到数据后，首先对数据帧拆包，将数据帧的源MAC拆分出来，如果交换机内部的存储器中没有此MAC地址，则将该MAC地址与其进入的端口保存起来，形成一个映射，这些信息就是MAC地址表。 二、交换机上VLAN的划分使用一台交换机和两台PC机，还将其中PC1作为控制台终端，使用Console口配置方式；使用两根网线分别将PC1和PC2连接到交换机的RJ-45接口上。要求：在交换机上划分两个基于端口的VLAN：VLAN100，VLAN200。使得VLAN100的成员能够互相访问，VLAN200的成员能够互相访问；VLAN100和VLAN200成员之间不能互相访问。PC1和PC2的网络设置为：PC1、PC2接在VLAN100的成员端口1~8上，两台PC互相可以ping通；PC1、PC2接在VLAN的成员端口9~16上，两台PC互相可以ping通；PC1接在VLAN100的成员端口1~8上，PC2接在VLAN200的成员端口9~16上，则互相ping不通。123456789101112131415&lt;HUAWEI&gt; system-view[HUAWEI] vlan batch 100 200[HUAWEI] port-group pg1[HUAWEI-port-group-pg1] group-member E0/0/1 to E0/0/8[HUAWEI-port-group-pg1] port link-type access[HUAWEI-port-group-pg1] port default vlan 100[HUAWEI] port-group pg2[HUAWEI-port-group-pg2] group-member E0/0/9 to E0/0/16[HUAWEI-port-group-pg2] port link-type access[HUAWEI-port-group-pg2] port default vlan 200int vlanif 1ip add 192.168.3.11 24 三、跨交换机VLAN要求：在交换机A和交换机B上分别划分两个基于端口的VLAN：VLAN100，VLAN200。使得交换机之间VLAN100的成员能够互相访问，VLAN200的成员能够互相访问；VLAN100和VLAN200成员之间不能互相访问。PC1和PC2的网络设置为： PC1、PC2分别接在不同交换机VLAN100的成员端口1~8上，两台PC互相可以ping通；PC1、PC2分别接在不同交换机VLAN的成员端口9~16上，两台PC互相可以ping通；PC1和PC2接在不同VLAN的成员端口上则互相ping不通。在交换机A配置：12345678910111213141516&lt;HUAWEI&gt; system-view[HUAWEI] port-group pg1[HUAWEI-port-group-pg1] group-member E0/0/1 to E0/0/8[HUAWEI-port-group-pg1] port link-type access[HUAWEI-port-group-pg1] port default vlan 100[HUAWEI] port-group pg2[HUAWEI-port-group-pg1] group-member E0/0/9 to E0/0/16[HUAWEI-port-group-pg1] port link-type access[HUAWEI-port-group-pg1] port default vlan 200int e 0/0/24port link-type trunkport trunk allow-pass vlan 100 200在交换机B配置：与A类似。 四、链路聚合SwitchA和SwitchB通过以太链路分别都连接VLAN10和VLAN20的网络，且SwitchA和SwitchB之间有较大的数据流量。用户希望SwitchA和SwitchB之间能够提供较大的链路带宽来使相同VLAN间互相通信。配置手工模式链路聚合实现上述要求。在SwitchA和SwitchB上创建Eth-Trunk接口并加入成员接口123456789101112131415161718192021&lt;HUAWEI&gt; system-view[HUAWEI] sysname SwitchA[SwitchA] interface eth-trunk 1[SwitchA-Eth-Trunk1] trunkport gigabitethernet 0/0/1 to 0/0/3&lt;HUAWEI&gt; system-view[HUAWEI] sysname SwitchB[SwitchB] interface eth-trunk 1[SwitchB-Eth-Trunk1] trunkport gigabitethernet 0/0/1 to 0/0/3创建VLAN并将接口加入VLAN。SwitchB的配置与SwitchA类似：[SwitchA] vlan batch 10 20[SwitchA] interface gigabitethernet 0/0/4[SwitchA-GigabitEthernet0/0/4] port link-type trunk[SwitchA-GigabitEthernet0/0/4] port trunk allow-pass vlan 10[SwitchA] interface gigabitethernet 0/0/5[SwitchA-GigabitEthernet0/0/5] port link-type trunk[SwitchA-GigabitEthernet0/0/5] port trunk allow-pass vlan 20配置Eth-Trunk1接口允许VLAN10和VLAN20通过。SwitchB的配置与SwitchA类似。[SwitchA] interface eth-trunk 1[SwitchA-Eth-Trunk1] port link-type trunk[SwitchA-Eth-Trunk1] port trunk allow-pass vlan 10 20 五、VLAN间通信在交换机LSW1上有两个VLAN（VLAN10和VLAN20），每个VLAN分配的IP地址块分别是192.168.1.0/24和192.168.2.0/24。为使VLAN间通信，在路由器的E0/0/0上配置子接口。要求：在交换机上配置VLAN10，将G0/0/2加入VLAN10；配置VLAN20，将G0/0/9加入VLAN20；配置交换机上的G0/0/1端口；配置路由器,实现VLAN终接。1234567891011121314151617181920交换机配置如下：vlan batch 10 20interface GigabitEthernet0/0/1port link-type trunkport trunk allow-pass vlan 10 20interface GigabitEthernet0/0/2port link-type accessport default vlan 10interface GigabitEthernet0/0/9port link-type accessport default vlan 20路由器配置如下：interface Ethernet0/0/0.1dot1q termination vid 10ip address 192.168.1.1 255.255.255.0arp broadcast enableinterface Ethernet0/0/0.2dot1q termination vid 20ip address 192.168.2.1 255.255.255.0arp broadcast enable 六、Trunk接口配置1、根据上图所示，在交换机SW1和SW2上创建VLAN10和VLAN20，将连接PC的接口配置为Access类型，并加入到相应的VLAN中。2、将交换机之间互联的链路配置为Trunk，使得该链路能够承载多VLAN流量。12345678910111213SW1配置如下：vlan batch 10 20interface gigabitEthernet 0/0/1port link-type accessport default vlan 10interface gigabitEthernet 0/0/2port link-type accessport default vlan 20interface gigabitEthernet 0/0/24port link-type trunkport trunk allow-pass vlan 10 20SW2配置如下：同SW1配置 七、使用多层交换机实现二层交换机VLAN之间的路由要求：在交换机A和交换机B上分别划分两个基于端口的VLAN：VLAN100，VLAN200。在交换机C上也划分两个基于端口的VLAN：VLAN100，VLAN200。把端口1和端口2都设置成Trunk口。交换机A的24口连接交换机C的1口，交换机B的24口连接交换机C的2口。PC1-PC4的网络设置为：1234567891011121314151617181920212223242526272829303132交换机A(交换机B类似)：vlan batch 100 200port-group pg1group-member e1 to e8port link-type accessport default vlan 100port-group pg2group-member e9 to e16port link-type accessport default vlan 200int e24port link-type trunkport trunk allow vlan 100 200交换机C：vlan batch 100 200int e1/1port link-type trunkport trunk allow vlan 100 200int e1/2port link-type trunkport trunk allow vlan 100 200int vlanif 100ip add 192.168.10.1 24int vlanif 200ip add 192.168.20.1 24 八、广域网数据链层协议的配置要求：左侧路由器S2/0地址1.1.1.1/24，f0/0地址192.168.1.1/24； 右侧路由器S1/0地址1.1.1.2/24，f0/0地址192.168.2.1/24；采用PPP封装，无验证。配置路由器串行接口封装，并配置IP地址1234567891011121314151617左侧路由器配置：system-viewinterface serial 4/0/0link-protocol pppip address 1.1.1.1 24interface gigabitEthernet 0/0/0ip address 192.168.1.1 24quitip route-static 192.168.2.0 24 1.1.1.2右侧路由器配置：system-viewinterface serial 4/0/0link-protocol pppip address 1.1.1.2 24interface gigabitEthernet 0/0/0ip address 192.168.2.1 24ip route-static 192.168.1.0 24 1.1.1.1 九、RIP配置在上图所示互连网中，路由器AR1与AR3使用同步串口相连，要求数据链层协议使用PPP；路由器AR2与AR3使用同步串口相连，要求数据链层协议使用帧中继，且DLCI值为100。每个路由器连接了一个以太局域网。路由器AR1端口G0/0/1和S4/0/0的IP地址分别为192.168.1.1/24和192.168.2.1/24；路由器AR3端口S4/0/0、G0/0/2和S4/0/1的IP地址分别为192.168.2.2/24、192.168.3.1/24和192.168.4.1/24；路由器AR2端口S4/0/0和G0/0/1的IP地址分别为192.168.4.2/24和192.168.5.1/24。同时要求各路由器使用RIP协议实现网络互通。123456789101112131415161718192021222324252627282930313233343536373839404142434445路由器AR1配置：system-viewint s4/0/0link-protocol pppip address 192.168.2.1 24int g0/0/1ip address 192.168.1.1 24quitrip 1version 2network 192.168.1.0network 192.168.2.0路由器AR2配置：sysint s4/0/0link-protocol frip address 192.168.4.2 24fr map ip 192.168.4.1 100int g0/0/1ip address 192.168.5.1 24quitrip 1version 2network 192.168.4.0network 192.168.5.0peer 192.168.4.1路由器AR3配置：sysint s4/0/0link-protocol pppip address 192.168.2.2 24int s4/0/1link-protocol frfr interface-type dcefr map ip 192.168.4.2 100ip address 192.168.4.1 24int g0/0/2ip address 192.168.3.1 24quitrip 1version 2network 192.168.2.0network 192.168.3.0network 192.168.4.0peer 192.168.4.2 十、OSPF配置设备接口编号及IP编址如下图所示，要求R1-R2之间运行RIPv2，R2-R3之间运行OSPF；在R2上完成路由重发布的配置，使得全网的路由能够互通。完成所有配置后，要求PC1与PC2能够互访。12345678910111213141516171819202122232425262728293031323334353637路由器R1配置：system-viewinterface GigabitEthernet 0/0/0ip address 192.168.12.1 24interface GigabitEthernet 0/0/1ip address 192.168.1.254 24rip 1version 2network 192.168.12.0network 192.168.1.0路由器AR2配置：system-view#完成接口IP的配置：interface GigabitEthernet 0/0/0ip address 192.168.12.2 24interface GigabitEthernet 0/0/1ip address 192.168.23.2 24#在R2的GE0/0/0上激活RIPv2：rip 1version 2network 192.168.12.0import-route ospf 1#在R2的GE0/0/1上激活OSPF：ospf 1 router-id 2.2.2.2area 0network 192.168.23.0 0.0.0.255import-route rip 1路由器AR3配置：system-viewinterface GigabitEthernet 0/0/0ip address 192.168.23.3 24interface GigabitEthernet 0/0/1ip address 192.168.2.254 24ospf 1 router-id 3.3.3.3area 0network 192.168.23.0 0.0.0.255network 192.168.2.0 0.0.0.255 十一、多区域及AS间OSPF配置在下图中ROUTE-C是ASBR，其E0/2与外部相连，不在OSPF的自治系统内。在外部网络中，ROUTE-C和ROUTE-D使用RIP协议。自治系统内使用OSPF协议。假设各路由器的基础配置已配好，试配置OSPF和RIP使网络互通。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950路由器B配置：int loopback 0ip address 11.10.10.1 24quitint s4/0/0ip address 172.16.24.2 24ospf 1area 0network 172.16.24.0 0.0.0.255路由器A配置：int loopback 0ip address 10.10.10.1 24int s4/0/0ip address 172.16.24.1 24ospf 1area 0network 172.16.24.0 0.0.0.255int s4/0/1ip address 172.16.25.1 24ospf 1area 1network 172.16.25.0 0.0.0.255路由器C配置：int loopback 0ip address 12.10.10.1 24int s4/0/0ip address 172.16.25.2 24ospf 1import-route riparea 1network 172.16.25.0 0.0.0.255int g0/0/0ip address 192.168.1.1 24rip 1version 2import-route ospfnetwork 192.168.1.0路由器D配置：sysint g0/0/0ip address 192.168.1.2 24int g0/0/1ip address 192.168.2.1 24rip 1version 2network 192.168.1.0network 192.168.2.0","categories":[],"tags":[]},{"title":"DOM事件流 事件代理  JS作用域和作用域链","slug":"20180622-js原型链","date":"2018-06-22T14:00:44.000Z","updated":"2018-06-25T10:06:35.000Z","comments":true,"path":"2018/06/22/20180622-js原型链/","link":"","permalink":"http://yoursite.com/2018/06/22/20180622-js原型链/","excerpt":"内马尔进球了 我，里奥·谢特，现在慌得一批（我才不是梅西黑粉）这次我们来看下dom事件流，事件代理和js中的作用域作用域链。 1.DOM事件流dom事件简单地说就是定义了一些JavaScript函数使他们能够响应页面元素发生的变化，如click事件。 事件的生命周期分为三个阶段 捕捉 目标 冒泡 a)捕捉阶段当某个事件被触发的时候，浏览器会找到涉及的元素，涉及的元素被称为目标，浏览器会先触发外层事件的处理器，最后才会轮到目标事件处理器。","text":"内马尔进球了 我，里奥·谢特，现在慌得一批（我才不是梅西黑粉）这次我们来看下dom事件流，事件代理和js中的作用域作用域链。 1.DOM事件流dom事件简单地说就是定义了一些JavaScript函数使他们能够响应页面元素发生的变化，如click事件。 事件的生命周期分为三个阶段 捕捉 目标 冒泡 a)捕捉阶段当某个事件被触发的时候，浏览器会找到涉及的元素，涉及的元素被称为目标，浏览器会先触发外层事件的处理器，最后才会轮到目标事件处理器。 b)目标阶段捕获阶段完成后，浏览器触发目标元素上任何已经添加的事件类型监听器。 c)冒泡阶段冒泡阶段与捕获阶段顺序正好相反，在这个阶段，浏览器会优先处理目标的事件处理器，然后一层层往外处理其余的事件处理器。 总结来说就是：冒泡事件按照最特定的事件目标到最不特定的事件目标的顺序触发。捕获事件是从最不特定的开始触发到最特定的事件。 看下这张图更助于理解 在JS中，绑定的事件默认的执行时间是在冒泡阶段执行，而非在捕获阶段，必须要理解 不过我们可以通过绑定事件时，指定事件执行时间是在冒泡阶段还是捕获阶段。 obj.addEventListener(event,function(){},bool) bool:false，代表冒泡阶段执行 bool:true，代表捕获阶段执行 JS在默认情况下获取事件后，就开始从根元素开始捕获所有该事件的监听对象，然后在冒泡阶段逐一执行。捕获阶段是在冒泡阶段前面 阻止冒泡 w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true； 阻止默认行为 w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false; ps:onclick,click,on()的优先关系：onclick&gt;click&gt;on()； onclick和click绑定的事件，彼此之间遵守事件冒泡规则，从内到外触发； on()绑定的事件，总是晚于onclick和click绑定的事件触发； 2.事件代理当我们需要对很多元素添加事件的时候，可以通过将事件添加到他的父节点而将事件委托给父节点来触发处理函数，这主要得益于浏览器的冒泡机制。123456789101112131415 &lt;ul id=\"parent-list\"&gt; &lt;li id=\"p1\"&gt;Item 1&lt;/li&gt; &lt;li id=\"p1\"&gt;Item 2&lt;/li&gt; &lt;li id=\"p1\"&gt;Item 3&lt;/li&gt; &lt;li id=\"p1\"&gt;Item 4&lt;/li&gt; &lt;/ul&gt; //下面实现事件代理 //获取父节点 为他添加一个click事件 document.getElementById(\"parent-list\").addEventListener(\"click\",function(e)&#123; //检查事件源e.target是否为li if(e.target &amp;&amp; e.target.nodeName.toUpperCase == \"LI\") //处理过程 console.log(\"List item\",e.target.id.replace(\"p\"),\"was clicked!\");&#125;); 为父节点添加一个click事件，当子节点被点击的时候，click事件会从子节点开始向上冒泡，通过判断e.target.nodeName来判断是否为我们需要处理的节点。并且通过e.target拿到了被点击的li节点。从而获取到相应的信息，并做处理。 我们可以用jQuery的delegate函数更为方便的处理1234$(\"#link-list\").delegate(\"a\",\"click\",function()&#123; //\"$(this)\"是被点击的节点 console.log(\"you clicked a link!\",$(this));&#125;); 3.JavaScript中的作用域和作用域链JavaScript函数的作用域：函数内的区域，就是这个函数的作用域，变量和函数在这个区域都可以访问操作。最外层函数外的区域叫全局作用域，函数内的区域叫局部作用域。 JavaScript变量的作用域：在源代码中变量所在的区域就是这个变量的作用域，变量在这个区域内可以被访问操作。在全局作用域上定义的变量叫全局变量，在函数内定义的变量叫局部变量（函数内声明但不加var 视为全局变量） 作用域链：作用域链（Scope Chain）是JavaScript内部的一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域，理解作用域链的作用原理。 执行环境：执行环境也被称为上下文，当解析器进入ECMAScript的可执行代码，解析器就进入一个执行环境，活动的执行环境组成一个逻辑上的栈，在这个逻辑栈顶部的执行环境就是当前运行的执行环境。 ps：ECMAScriptt中有三种可执行代码，Global、Function和Eval： eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript)字符串。看下面的例子： eval(“alert(‘专业做网站’)”)； 这行代码的作用等价于下面这行代码： alert(“专业做网站”); 全局环境即是Global可执行代码，函数即是Function可执行代码。逻辑栈是一种特殊的数据存储格式，特点是‘先进后出，后进先出’，添加数据会先压入逻辑栈顶部，删除数据必须先从顶部开始删除。 变量对象(Variable Object)、活动对象(Activation Object)和Arguments对象(Arguments Object) 每个执行环境都有一个与之关联的变量对象，当解析器进入执行环境时，就会创建一个变量对象，变量对象保存着在当前执行环境中声明的变量和函数的引用。 变量对象是一个抽象的概念，在不同的执行环境中，变量对象有不同的身份，在解析器进入任何执行环境之前，就已经创建了一个Global对象，当解析器进入全局执行环境时，Global对象就充当变量对象，当解析器进入一个函数时，就会创建一个活动对象充当变量对象。 解析器处理代码时的两个阶段:JavaScript解析器是一段一段解析处理代码的，解析器处理代码时的两个阶段：解析代码和执行代码。 当解析器进入执行环境时，变量对象就会添加执行环境中声明的变量和函数作为它的属性，这就意味着变量和函数在声明之前已经可用，变量值为undefined，这就是变量和函数声明提升(Hoisting)的原因，与此同时作用域链和this确定，此过程为解析阶段，俗称预解析。接着解析器开始执行代码，为变量添加相应值的引用，得到执行结果，此过程为执行阶段。 举个栗子12345var a=123;var b=\"abc\";function c()&#123; alert('11');&#125; 上述全局环境中的代码解析执行后，会将Global对象作为变量对象，保存以下数据。 12345678function testFn(a)&#123; var b=\"123\"; function c()&#123; alert(\"abc\"); &#125;&#125;testFn(10); 当解析器进入函数执行环境时，则会创建一个活动对象作为变量对象，活动对象还会创建一个Arguments对象，arguments对象是一个参数集合，用来保存参数，这就是我们写函数时可以使用arguments[0]等来使用参数的原因。 作用域链：每个执行环境都有一个与之关联的作用域链，当解析器进入执行环境时被定义，作用域链是一个对象列表，用来检索各个变量对象中的变量和函数，这样可以保证执行环境有权访问哪些变量和函数，举个栗子。12345678910111213var a='123';function testFn(b)&#123; var c='abc'; function testFn2()&#123; var d='efg'; alert(a); &#125; testFn2();&#125;testFn(10); testFn2内未声明变量a，为什么testFn2能调用全局变量a？整个过程是怎么发生的呢？请看下图。 当解析器进入全局执行环境时，调用变量和函数时只在Global对象中查找。 当解析器进入testFn函数执行环境时，函数内部属性[[scope]]中首先填入Global对象，然后将testFn活动对象添加到Global对象之前，形成一个作用域链当解析器进入testFn2函数执行环境时，函数内部属性[[scope]]首先填入父级的作用域链，然后再将当前的testFn2活动对象添加到作用域链的前端，形成一个新的作用域链。 testFn2调用变量a时，首先在当前的testFn2活动对象中查找，如果没有找到就顺着作用域链向上，在testFn活动对象中查找变量a，如果没有找到再顺着作用域链向上查找，直到在最后Global对象中找到为止，否则报错。所以函数内部可以调用外部环境的变量，外部环境不能调用函数内部的变量，这就是作用域特性的原理。 参考文献：作者未知\u0000\u0000\b","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Javascript闭包初步了解","slug":"20180622-js闭包","date":"2018-06-22T09:47:44.000Z","updated":"2018-06-25T10:06:39.000Z","comments":true,"path":"2018/06/22/20180622-js闭包/","link":"","permalink":"http://yoursite.com/2018/06/22/20180622-js闭包/","excerpt":"没错，在下就是这么勤劳 ，这里来总结一下js闭包，搬运自阮大佬的日志 闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。1.变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。","text":"没错，在下就是这么勤劳 ，这里来总结一下js闭包，搬运自阮大佬的日志 闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。1.变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 1234567var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 12345 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！1234567 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 2.如何从外部读取局部变量出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789101112131415function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 3.闭包的概念上面代码中的f2函数，就是闭包。 各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我(阮大佬)的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 4.闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。123456789101112131415161718192021 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 5.使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 常见陷阱12345678910111213function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; console.log(funcs[i]());&#125; 乍一看，以为输出 0~9 ，万万没想到输出10个10？ 这里的陷阱就是：函数带()才是执行函数， 单纯的一句 var f = function() { alert(‘Hi’); }; 是不会弹窗的，后面接一句 f(); 才会执行函数内部的代码。上面代码翻译一下就是：12345678910111213var result = new Array(), i;result[0] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！result[1] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！...result[9] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！i = 10;funcs = result;result = null;console.log(i); // funcs[0]()就是执行 return i 语句，就是返回10console.log(i); // funcs[1]()就是执行 return i 语句，就是返回10...console.log(i); // funcs[9]()就是执行 return i 语句，就是返回10 为什么只垃圾回收了 result，但却不收了 i 呢？ 因为 i 还在被 function 引用着啊。好比一个餐厅，盘子总是有限的，所以服务员会去巡台回收空盘子，但还装着菜的盘子他怎么敢收？ 当然，你自己手动倒掉了盘子里面的菜（=null），那盘子就会被收走了，这就是所谓的内存回收机制。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"前端跨域问题的解决方案","slug":"20180623-前端跨域问题的解决方法","date":"2018-06-22T07:47:44.000Z","updated":"2018-06-22T10:28:14.000Z","comments":true,"path":"2018/06/22/20180623-前端跨域问题的解决方法/","link":"","permalink":"http://yoursite.com/2018/06/22/20180623-前端跨域问题的解决方法/","excerpt":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧 1.什么是跨域 域名 说明 是否跨域 http://www.a.com/a.js http://www.a.com/b.js 同一域名 否 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名文件夹不同 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名端口不同 是 http://www.a.com/a.js https://www.a.com/b.js 同一域名协议不同 是 http://www.a.com/a.js http://70.32.92.74/b.js 对应ip相同 是 http://www.a.com/a.js http://script.a.com/b.js 子域名不同 是 http://www.bilibili.com/a.js http://www.a.com/b.js 不同域名 是 2.解决方法1.JSONP实现跨域JSONP是json with padding（填充式json或参数式json）的简称","text":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧 1.什么是跨域 域名 说明 是否跨域 http://www.a.com/a.js http://www.a.com/b.js 同一域名 否 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名文件夹不同 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名端口不同 是 http://www.a.com/a.js https://www.a.com/b.js 同一域名协议不同 是 http://www.a.com/a.js http://70.32.92.74/b.js 对应ip相同 是 http://www.a.com/a.js http://script.a.com/b.js 子域名不同 是 http://www.bilibili.com/a.js http://www.a.com/b.js 不同域名 是 2.解决方法1.JSONP实现跨域JSONP是json with padding（填充式json或参数式json）的简称JSONP包含两部分：回调函数和数据。 JSONP实现跨域请求的原理是动态创建&lt;script&gt;标签，然后利用&lt;script&gt;的src 不受同源策略约束来跨域获取数据1234567function handleResponse(response)&#123; console.log(response.data);&#125;var script = document.createElement('script');script.src = 'http:/www.domain.com/json?callback=handleResponse';document.body.insertBefore(script, document.body.firstChild);//handleResonse(&#123;\"data\": \"zhe\"&#125;) 具体流程：通过script标签请求时后台根据相应的参数(json,handleResponse)来生成相应的json数据(handleResponse({&quot;data&quot;: &quot;zhe&quot;}))，最后这个返回的json数据就会被放在当前js文件中被执行。 JSONP的缺陷：1、请求代码存在安全隐患。借助JSONP有可能进行跨站请求伪造(CSRF)攻击。2、无法确定jsonp成功与否3、只能实现get请求1234567$.ajax(&#123; url: 'http://www.domain.com/json', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;); 2.document.domain + iframe实现跨域这个方案只适用于主域名相同，子域名不同的跨域处理。 原理是通过js强制设置document.domain 为基础主域。 123456789101112//父窗口www.domain.com/a.html&lt;iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt;//子窗口child.domain.com/b.html&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 3.location.hash+iframe实现跨域原理是利用location.hash来进行传值。 假设域名a.com下的文件cs1.html要和domain.com域名下的cs2.html传递信息。1) cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向domain.com域名下的cs2.html页面2) cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据3) 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //先是a.com下的文件cs1.html文件：function startRequest()&#123; var ifr = document.createElement('iframe'); ifr.style.display = 'none'; ifr.src = 'http://www.domain.com/lab/cscript/cs2.html#paramdo'; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : ''; if (console.log) &#123; console.log('Now the data is '+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000);//cnblogs.com域名下的cs2.html://模拟一个简单的参数处理操作switch(location.hash)&#123; case '#paramdo': callBack(); break; case '#paramset': //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = 'somedata'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = 'http://a.com/test/cscript/cs3.html#somedata'; // 注意该文件在\"a.com\"域下 document.body.appendChild(ifrproxy); &#125;&#125;//a.com下的域名cs3.html//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 4. window.name + iframe实现跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 原理是通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//1.）a.html：(www.domain1.com/a.html)var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data);&#125;);//2.）proxy.html：(www.domain1.com/proxy....//中间代理页，与a.html同域，内容为空即可。//3.）b.html：(www.domain2.com/b.html)&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 5.postMessage实现跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 12345678910111213141516171819202122232425262728293031323334//1.）a.html：(www.domain1.com/a.html)&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt;//2.）b.html：(www.domain2.com/b.html)&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; 6.CORS（跨域资源共享）实现跨域CORS是通过一系列特殊的HTTP头来解决这一问题，这些http头信息可以允许双方判断请求成功或者失败 在发送跨域HTTP请求时，支持CORS的浏览器会引入额外的Origin头信息来指定请求的源。这个头信息需要包含三个部分——协议、域名和端口 服务端的工作是检查头信息是否接受该请求。如果请求被接受，那么需要返回一个包含Access-Control-Allow-Origin，其值与客户端Origin值相同的响应头 如果资源是公共的允许任何源发送请求，服务器可以返回一个通配符Access-Control-Allow-Origin: *如果匹配成功，那么浏览器将会继续处理这个请求，否则禁止该请求。123456789101112131415161718192021222324252627282930//1.）原生ajax// 前端设置是否带cookiexhr.withCredentials = true;示例代码：var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;;//2.）jQuery ajax$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); java中后台可以这样设置12345 //导入包：import javax.servlet.http.HttpServletResponse; //接口参数中定义：HttpServletResponse responseresponse.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\"); // 若有端口需写全（协议+域名+端口）response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); 7.Nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 配置信息：123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 前端代码12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); node.js后台 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 8.Web Sockets实现跨域web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。 12345var socket = new WebSockt('ws://www.domain.com');//http-&gt;ws; https-&gt;wsssocket.send('hello WebSockt');socket.onmessage = function(event)&#123; var data = event.data;&#125; 参考资料阮一峰大佬的CORS 详解","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"ES6这些就够了","slug":"20180625-ES6","date":"2018-06-21T15:47:44.000Z","updated":"2018-06-25T10:04:46.000Z","comments":true,"path":"2018/06/21/20180625-ES6/","link":"","permalink":"http://yoursite.com/2018/06/21/20180625-ES6/","excerpt":"本来想自己写点ES6的东西但是查相关的资料的时候找到了不错的，这里就搬运一下吧。原文地址：简书作者 陈嘻嘻啊：ES6这些就够了 PS：ECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言 刚开始用vue或者react，很多时候我们都会把ES6这个大兄弟加入我们的技术栈中。但是ES6那么多那么多特性，我们真的需要全部都掌握吗？秉着二八原则，掌握好常用的、有用的这个可以让我们的开发快速起飞。 接下来我们就聊聊ES6那些可爱的新特性吧。1.变量声明const和let在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如:","text":"本来想自己写点ES6的东西但是查相关的资料的时候找到了不错的，这里就搬运一下吧。原文地址：简书作者 陈嘻嘻啊：ES6这些就够了 PS：ECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言 刚开始用vue或者react，很多时候我们都会把ES6这个大兄弟加入我们的技术栈中。但是ES6那么多那么多特性，我们真的需要全部都掌握吗？秉着二八原则，掌握好常用的、有用的这个可以让我们的开发快速起飞。 接下来我们就聊聊ES6那些可爱的新特性吧。1.变量声明const和let在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如:1234567function aa() &#123; if(bool) &#123; var test = 'hello man' &#125; else &#123; console.log(test) &#125;&#125; 以上的代码实际上是：12345678910function aa() &#123; var test // 变量提升 if(bool) &#123; test = 'hello man' &#125; else &#123; //此处访问test 值为undefined console.log(test) &#125; //此处访问test 值为undefined &#125; 以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。 接下来ES6主角登场：我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？ 在一个函数内部 在一个代码块内部 说白了 {}大括号内的代码块即为let 和 const的作用域。 看以下代码：12345678function aa() &#123; if(bool) &#123; let test = 'hello man' &#125; else &#123; //test 在此处访问不到 console.log(test) &#125;&#125; let的作用域是在它所在当前代码块，但不会被提升到当前函数的最顶部。 再来说说constconst 声明的变量都会被认为是常量，意思就是它的值被设置完成后就不能再修改了。12const name = 'lux'name = 'joe' //再次赋值此时会报错 还有，如果const的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址没有变就行。12345const student = &#123; name: 'cc' &#125;// 没毛病student.name = 'yy'// 如果这样子就会报错了student = &#123; name: 'yy' &#125; 说一道面试题1234567var funcs = [] for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;) &#125; funcs.forEach(function(func) &#123; func() &#125;) 这样的面试题是大家常见，很多同学一看就知道输出 10 十次但是如果我们想依次输出0到9呢？有两种解决方法。直接看一下代码。1234567891011121314// ES5告诉我们可以利用闭包解决这个问题 var funcs = [] for (var i = 0; i &lt; 10; i++) &#123; funcs.push( (function(value) &#123; return function() &#123; console.log(value) &#125; &#125;)(i) ) &#125; funcs.forEach(function(func) &#123; func() &#125;) 12345678// 再来看看es6怎么处理的 const funcs = [] for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;) &#125; funcs.forEach(func =&gt; func()) 达到相同的效果，es6简洁的解决方案是不是更让你心动！！！ 2.模板字符串ES6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。 第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。123456//ES5 var name = 'lux' console.log('hello' + name) //es6 const name = 'lux' console.log(`hello $&#123;name&#125;`) //hello lux 第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号()直接搞定。12345678// ES5 var msg = \"Hi \\ man! \" // ES6 const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt;` 对于字符串ES6当然也提供了很多厉害也很有意思的方法😊 说几个常用的。1234567891011121314// 1.includes：判断是否包含然后直接返回布尔值 const str = 'hahay' console.log(str.includes('y')) // true // 2.repeat: 获取字符串重复n次 const str = 'he' console.log(str.repeat(3)) // 'hehehe' //如果你带入小数, Math.floor(num) 来处理 // s.repeat(3.1) 或者 s.repeat(3.9) 都当做成 s.repeat(3) 来处理 // 3. startsWith 和 endsWith 判断是否以 给定文本 开始或者结束 const str = 'hello world!' console.log(str.startsWith('hello')) // true console.log(str.endsWith('!')) // true 3.函数函数默认参数在ES5我们给函数定义参数默认值是怎么样？123456function action(num) &#123; num = num || 200 //当传入num时，num为传入的值 //当没传入参数时，num即有了默认值200 return num &#125; 但细心观察的同学们肯定会发现，num传入为0的时候就是false，但是我们实际的需求就是要拿到num = 0，此时num = 200 明显与我们的实际想要的效果明显不一样 ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。123456function action(num = 200) &#123; console.log(num) &#125; action(0) // 0 action() //200 action(300) //300 箭头函数ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。 箭头函数最直观的三个特点。 不需要 function 关键字来创建函数 省略 return 关键字 继承当前上下文的 this 关键字1234567//例如： [1,2,3].map(x =&gt; x + 1)//等同于： [1,2,3].map((function(x)&#123; return x + 1 &#125;).bind(this)) 这里我插一段call，apply，bind的介绍吧 js在开发的过程中经常会用到this，来表示当前运行环境本身，通过this来取得当前环境下的各种数据和方法。但是，有时候我们想要让a对象借b对象的方法用一下，要怎么办呢？例如：12345678910111213141516var person = &#123; name: '鲸某人', sayName: function()&#123; console.log(this.name) &#125;&#125;var person1 = &#123; name: '高某人'&#125;//如果我们想让鲸某人叫一下高某人，咋办呢？//只要call他一下就可以啦person.sayName.call(person1)//同样的，使用apply和bind也可以达到相同的效果：person.sayName.apply(person1)//下边会说，为什么bind后边多了个()person.sayName.bind(person1)() apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 。。继续说箭头函数当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return；例如:12var people = name =&gt; 'hello' + name //参数name就没有括号 作为参考12345var people = (name, age) =&gt; &#123; const fullName = 'hello' + name return fullName&#125;//如果缺少()或者&#123;&#125;就会报错 要不整一道笔试题？哈哈哈哈哈哈哈哈。我不管我先上代码了1234567891011121314// 请使用ES6重构以下代码 var calculate = function(x, y, z) &#123; if (typeof x != 'number') &#123; x = 0 &#125; if (typeof y != 'number') &#123; y = 6 &#125; var dwt = x % y var result if (dwt == z) &#123; result = true &#125; if (dwt != z) &#123; result = false &#125; return result &#125; 123456const calculate = (x, y, z) =&gt; &#123; x = typeof x !== 'number' ? 0 : x y = typeof y !== 'number' ? 6 : y return x % y === z &#125; 4.拓展的对象功能对象初始化简写 ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如：123456function people(name, age) &#123; return &#123; name: name, age: age &#125;; &#125; 键值对重名，ES6可以简写如下：123456function people(name, age) &#123; return &#123; name, age &#125;; &#125; ES6 同样改进了为对象字面量方法赋值的语法。ES5为对象添加方法：123456const people = &#123; name: 'lux', getName: function() &#123; console.log(this.name) &#125; &#125; ES6通过省略冒号与 function 关键字，将这个语法变得更简洁123456const people = &#123; name: 'lux', getName () &#123; console.log(this.name) &#125; &#125; ES6 对象提供了 Object.assign()这个方法来实现浅复制。Object.assign() 可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}1234567891011121314const objA = &#123; name: 'cc', age: 18 &#125; const objB = &#123; address: 'beijing' &#125; const objC = &#123;&#125; // 这个为目标对象 const obj = Object.assign(objC, objA, objB) // 我们将 objA objB objC obj 分别输出看看 console.log(objA) // &#123; name: 'cc', age: 18 &#125; console.log(objB) // &#123; address: 'beijing' &#125; console.log(objC) // &#123; name: 'cc', age: 18, address: 'beijing' &#125; console.log(obj) // &#123; name: 'cc', age: 18, address: 'beijing' &#125; // 是的，目标对象ObjC的值被改变了。 // so，如果objC也是你的一个源对象的话。请在objC前面填在一个目标对象&#123;&#125; Object.assign(&#123;&#125;, objC, objA, objB) 5.更方便的数据访问–解构数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程 ES5我们提取对象中的信息形式如下：1234567const people = &#123; name: 'lux', age: 20 &#125; const name = people.name const age = people.age console.log(name + ' --- ' + age) 是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，解构能让我们从对象或者数组里取出数据存为变量，例如123456789101112//对象 const people = &#123; name: 'lux', age: 20 &#125; const &#123; name, age &#125; = people console.log(`$&#123;name&#125; --- $&#123;age&#125;`) //数组 const color = ['red', 'blue'] const [first, second] = color console.log(first) //'red' console.log(second) //'blue' 要不来点儿面试题，看看自己的掌握情况？123456789// 请使用 ES6 重构一下代码 // 第一题 var jsonParse = require('body-parser').jsonParse // 第二题 var body = request.body var username = body.username var password = body.password 1234// 1. import &#123; jsonParse &#125; from 'body-parser' // 2. const &#123; body, body: &#123; username, password &#125; &#125; = request 6.Spread Operator 展开运算符ES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。 组装对象或者数组12345678910//数组 const color = ['red', 'yellow'] const colorful = [...color, 'green', 'pink'] console.log(colorful) //[red, yellow, green, pink] //对象 const alp = &#123; fist: 'a', second: 'b'&#125; const alphabets = &#123; ...alp, third: 'c' &#125; console.log(alphabets) //&#123; \"fist\": \"a\", \"second\": \"b\", \"third\": \"c\"&#125; 有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项1234567891011121314//数组 const number = [1,2,3,4,5] const [first, ...rest] = number console.log(rest) //2,3,4,5 //对象 const user = &#123; username: 'lux', gender: 'female', age: 19, address: 'peking' &#125; const &#123; username, ...rest &#125; = user console.log(rest) //&#123;\"address\": \"peking\", \"age\": 19, \"gender\": \"female\"&#125; 对于 Object 而言，还可以用于组合成新的 Object 。(ES2017 stage-2 proposal) 当然如果有重复的属性名，右边覆盖左边1234567891011const first = &#123; a: 1, b: 2, c: 6, &#125; const second = &#123; c: 3, d: 4 &#125; const total = &#123; ...first, ...second &#125; console.log(total) // &#123; a: 1, b: 2, c: 3, d: 4 &#125; 7.import 和 exportimport导入模块、export导出模块123456789101112131415161718//全部导入import people from './example'//有一种特殊情况，即允许你将整个模块当作单一对象进行导入//该模块的所有导出都会作为对象的属性存在import * as example from \"./example.js\"console.log(example.name)console.log(example.age)console.log(example.getName())//导入部分import &#123;name, age&#125; from './example'// 导出默认, 有且只有一个默认export default App// 部分导出export class App extend Component &#123;&#125;; 导入的时候有没有大括号的区别是什么1234567891.当用export default people导出时，就用 import people 导入（不带大括号）2.一个文件里，有且只能有一个export default。但可以有多个export。3.当用export name 时，就用import &#123; name &#125;导入（记得带上大括号）4.当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, &#123; name, age &#125;5.当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example 8. Promise 在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。 说白了就是用同步的方式去写异步代码。 发起异步请求1234fetch('/api/todos') .then(res =&gt; res.json()) .then(data =&gt; (&#123; data &#125;)) .catch(err =&gt; (&#123; err &#125;)); 详细的用法可以参考这几篇文章 Promise使用详解1 Promise使用详解2 Promise使用详解3 9.Generators生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。 这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。 OK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。 12345678910111213// 生成器 function *createIterator() &#123; yield 1; yield 2; yield 3; &#125; // 生成器能像正规函数那样被调用，但会返回一个迭代器 let iterator = createIterator(); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 那生成器和迭代器又有什么用处呢？ 围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。 生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。 那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的12345678910111213141516171819202122function run(taskDef) &#123; //taskDef即一个生成器函数 // 创建迭代器，让它在别处可用 let task = taskDef(); // 启动任务 let result = task.next(); // 递归使用函数来保持对 next() 的调用 function step() &#123; // 如果还有更多要做的 if (!result.done) &#123; result = task.next(); step(); &#125; &#125; // 开始处理过程 step(); &#125; 生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。你不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 yield 来等待异步操作结束。 ES6新特性远不止于此，但对于我们日常的开发来说。这算不上全部，但是能算得上是高频使用了。当然还有很有好玩有意思的特性。比如一些数组的新方法、class…等等。包括用set处理数组去重问题等等。最后感谢大佬的归纳总结。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"web性能优化","slug":"Web性能优化","date":"2018-06-21T15:47:44.000Z","updated":"2018-06-24T13:17:56.000Z","comments":true,"path":"2018/06/21/Web性能优化/","link":"","permalink":"http://yoursite.com/2018/06/21/Web性能优化/","excerpt":"Web性能优化1、 减少http请求a) 在浏览器和服务器发生通信的时候 就已经消耗了大量的时间b) 网速相同的条件下 下载一个100kb的图片比下载两个50kb的图片要快c) 减少http请求的主要手段是合并css 合并JavaScript 合并图片","text":"Web性能优化1、 减少http请求a) 在浏览器和服务器发生通信的时候 就已经消耗了大量的时间b) 网速相同的条件下 下载一个100kb的图片比下载两个50kb的图片要快c) 减少http请求的主要手段是合并css 合并JavaScript 合并图片 2、 使用浏览器缓存a) 一个网站中 css js logo 图标这些静态资源文件更新的频率都比较低 如果将这些文件缓存在浏览器中可以极好地改善型性能b) 通过设置http头中的cache-control和expires属性 可以设定浏览器缓存c) 在某些时候 静态资源文件变化需要及时应用到客户端浏览器 这种情况 可以通过改变文件名称实现 即更新js文件不是更新js文件内容d) 使用浏览器缓存策略的网站在更新静态资源时 应采用分批次更新的方法 比如需要更新10个图标文件 不宜把10个文件一次全部更新 应该一个文件一个文件逐步更新 并有一定的间隔时间 以免浏览器突然大量缓存失效 3、 服务端启用压缩4、 css放在页面最上面 js放在页面最下面a) 浏览器会在下载完全部css之后才对整个页面进行渲染 因此最好的做法是将css放在页面最上面 让浏览器尽快下载cssb) Js则相反 浏览器在加载js后立即执行 有可能会阻塞整个页面 造成页面显示缓慢 因此js最好放在页面最下面 但如果解析页面的时候就需要用到js 这里就不适合放在底部了 5、 精简css和js文件a) css和js压缩 减少下载的文件体积 常用的方式是使用 yui compressor 它的特点是：移除注释 移除额外的空格 细微的优化 标识符替换b) 压缩js java -jar yuicompressor-2.4.2.jar api.js&gt;api.min.js 压缩css java -jar yuicompressor-2.4.2.jar style.css&gt;style.min.css 6、 减少对dom的操作a) 对dom操作的代价是高昂的b) 修改和访问dom元素会造成页面的重绘和重排 造成重绘重排的原因i. 修改domii. 修改样式表iii. 用户事件c) 网页生成的过程大致可以分为五个步骤i. html转换成domii. css代码转换成cssomiii. 结合dom和cssom 生成一棵渲染树iv. 生成布局 即将所有渲染树的所有节点进行平面合成v. 将布局绘制在屏幕上 7、 使用json格式进行数据交换8、 减少cookie传输a) 因为cookie是本地的磁盘文件 每次浏览器都会去读取相应的cookie所以建议去除不必要的cookie 使cookie体积尽量小 9、 使用cdn加速a) cdn全称是content delivery network 即内容分发网络b) cdn本质仍然是一个缓存 而且将数据缓存在离用户最近的地方 使用户最快的获取数据c) cdn能够缓存的一般般是静态资源 如图片 文件 css script脚本 静态网页d) 实时性不好使cdn的缺陷","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"linux中常见的指令","slug":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？","date":"2018-06-21T12:47:44.000Z","updated":"2018-06-21T14:31:14.000Z","comments":true,"path":"2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","link":"","permalink":"http://yoursite.com/2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","excerpt":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？ 查看当前进程：ps 查看负载情况：free 查看内存的使用情况 top 动态显示cpu的负载情况 执行退出：exit 查看当前路径：pwd","text":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？ 查看当前进程：ps 查看负载情况：free 查看内存的使用情况 top 动态显示cpu的负载情况 执行退出：exit 查看当前路径：pwd 2.如何清屏？怎么退出当前命令？怎么执行s会面？ 清屏：clear 退出当前：ctrl+c 执行睡眠：ctrl+z fg恢复后台 3.ls命令执行什么功能？可以带哪些参数？ ls执行的功能：列出指定目录中的目录，以及文件 有哪些参数：a所有文件 l详细信息，包括大小写字节数，可读可写，可执行的权限等 4.目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？创建目录：mkdir创建文件：典型的如touch vi复制文件：cp 5.查看文件内容的命令有哪些？vi 文件名 编辑方式查看，可以修改cat 文件名 显示全部文件内容more 文件名 分页显示文件内容less 文件名 与more相似 可以往前翻页tail 文件名 仅查看尾部 可以指定行数head 文件名 仅查看头部 可以指定行数 6.移动文件 改名 用哪个命令？mv改名 将文件test改为new mv test new1 mv将目录 /usr/men中的所有文件移到当前目录 mv /usr/men/*. 7.复制 删除文件复制 cp [-adfilprsu] 源文件(source) 目标文件(destination) 删除 rm [fir] 文件或目录 8.常用的通配符和含义“？”可替代单个字符。 ·“*”可替代任意多个字符。 ·方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC] 15. 用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)wc 命令 - c 统计字节数。 – l 统计行数。 - w 统计字数。 9.终止进程kill -9 pid 10.查找自己所在终端的信息who am i","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]}]}