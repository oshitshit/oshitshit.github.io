{"meta":{"title":"司机小张","subtitle":"苟利国家生死以","description":null,"author":"司机小张","url":"http://yoursite.com"},"pages":[{"title":"Linux","date":"2018-06-21T07:46:09.000Z","updated":"2018-06-21T07:46:09.000Z","comments":true,"path":"Linux/index.html","permalink":"http://yoursite.com/Linux/index.html","excerpt":"","text":""},{"title":"Favorite","date":"2018-06-23T15:00:44.000Z","updated":"2019-04-05T12:58:54.000Z","comments":true,"path":"favorite/index.html","permalink":"http://yoursite.com/favorite/index.html","excerpt":"","text":"也许你听说过，「业余时间决定人生」；也许你还听说过，「听过很多道理，依然过不好这一生」。书籍、代码、博客、运动、电影、动漫、游戏，这就是我的业余生活。 我的能力就这么多。我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 趁我在还能写得动代码看得进书的年纪，努力一回，看看这平庸的资质究竟能发挥几分.hexo-image-steam-lazy {display:block;}.hexo-img-stream{width:90%;max-width:1100px;margin:3% auto}div.hexo-img-stream figure{background:#fefefe;box-shadow:0 1px 2px rgba(34,25,25,0.4);margin:0 0.05% 3%;padding:3%;padding-bottom:10px;display:inline-block;max-width:25%}div.hexo-img-stream figure img{border-bottom:1px solid #ccc;padding-bottom:15px;margin-bottom:5px}div.hexo-img-stream figure figcaption{font-size:.9rem;color:#444;line-height:1.5;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}div.hexo-img-stream small{font-size:1rem;float:right;text-transform:uppercase;color:#aaa}div.hexo-img-stream small a{color:#666;text-decoration:none;transition:.4s color}@media screen and (max-width:750px){.hexo-img-stream{column-gap:0}}西虹市首富 轻羽飞扬 我不是药神 Docker进阶与实战 命运石之门0 STEINS;GATE 0 亿级流量网站架构核心技术 Redis设计与实现 宅男腐女恋爱真难 DARLING in the FRANXX $('img.hexo-image-steam-lazy').lazyload({ effect:'fadeIn' });"}],"posts":[{"title":"想开大车住大房养大狗睡大床","slug":"hello-world","date":"2022-11-06T07:47:44.000Z","updated":"2019-04-05T14:34:20.000Z","comments":true,"path":"2022/11/06/hello-world/","link":"","permalink":"http://yoursite.com/2022/11/06/hello-world/","excerpt":"封面id=74015403 故事的开始要从刚来西二旗那年说起。。。","text":"封面id=74015403 故事的开始要从刚来西二旗那年说起。。。","categories":[],"tags":[]},{"title":"Flink SQL-Client探索","slug":"20190507-Flink SQL-Client","date":"2019-05-07T11:13:44.000Z","updated":"2019-05-07T11:17:03.477Z","comments":true,"path":"2019/05/07/20190507-Flink SQL-Client/","link":"","permalink":"http://yoursite.com/2019/05/07/20190507-Flink SQL-Client/","excerpt":"SQL-Client 就是一个便于大家学习和写 demo 的一个 Flink-SQL 工具，这次文章的基本流程还是根据社区云邪大佬的公开课，和 官方 wiki 的步骤执行的，这里就大体自己捣鼓了一遍记录一下。","text":"SQL-Client 就是一个便于大家学习和写 demo 的一个 Flink-SQL 工具，这次文章的基本流程还是根据社区云邪大佬的公开课，和 官方 wiki 的步骤执行的，这里就大体自己捣鼓了一遍记录一下。 前提准备 从 GitHub 上 clone ververica/sql-training 的 Docker 镜像地址为：https://github.com/ververica/sql-training 包含如下镜像：执行 docker-compose up -d加载镜像执行 docker-compose exec sql-client ./sql-client.sh启动 sql-client 看到松鼠就代表跑起来了！执行 docker-compose down终止 具体实践 执行show tables;我们先看一下自带了这几张表如果你想自己自定义表需要到 sql-training/build-image/training-config.yaml下去自定义表结构，具体操作可以参照官方的文档，这次主要用到 Rides这张表 Rides 的表结构是这样的 字段 类型 含义 rideId BIGINT 行为 ID（包含两条记录，一条入一条出） taxiId BIGINT 出租车 ID isStart BOOLEAN 开始 or 结束 lon FLOAT 经度 lat FLOAT 维度 rideTime TIMESTAMP 时间 psgCnt INT 乘客数 这里我们顺便介绍下training-config.yaml里的结构，sql-client 目前是提供了配置的方式定义表结构，如下： type：声明是一个 source 还是 sink。 update-mode：表里面的数据是什么行为 append 模式 update 模式 schema：表结构字段的定义。 具体介绍一下rideTime事件发生的时间，需要基于这个时间来做一些窗口的操作，因此要把这个字段声明为rowtime字段添加watermark，watermark是Flink里的时间机制，之后的文章再做详细介绍。 connector：主要定义连接配置，像Kafka，Elasticsearch等。 format：定义如何去解析定义的格式。 我们先来简单的执行一个 SQL 语句 select * from Rides;看一下 Rides表数据这时候打开 http://localhost:8081/ （Flink Web）可以发现刚才的 SQL 任务已经跑起来了同时终端也运行出了结果 需求 1（filter） 现在有这么一个需求，统计出现在纽约的行车记录。这里我们需要进行一个过滤的操作，我们需要有个自定义的 UDF ，具体思路是，表里面有经度和维度这两个字段，通过这个可以来开发一个是否在纽约的 UDF。（这里官方 Demo 里已经帮我们写好了2333）代码都在 sql-training/build-image/sql-udfs下的IsInNYC，继承 ScalarFunction类实现 eval方法。123456789101112131415161718public class IsInNYC extends ScalarFunction &#123; // geo boundaries of the area of NYC private static double LON_EAST = -73.7; private static double LON_WEST = -74.05; private static double LAT_NORTH = 41.0; private static double LAT_SOUTH = 40.5; public boolean eval(float lon, float lat) &#123; return isInNYC(lon, lat); &#125; public static boolean isInNYC(float lon, float lat) &#123; return !(lon &gt; LON_EAST || lon &lt; LON_WEST) &amp;&amp; !(lat &gt; LAT_NORTH || lat &lt; LAT_SOUTH); &#125;&#125; 然后我们执行 mvn clean package得到 UDF 的 jar 包，然后把它扔到 sql-client 的 lib下，然后再去 training-config.yaml下去配置一下 functions这里官方的 Demo 已经全帮我们做好了，我们去 sql-client 里查看一下已经有了 isInNYC的 UDF，这样我们就可以用这个 UDF 来筛选出在纽约的行车记录。执行 select * from Rides where isInNYC(lon,lat);结果如下：跑出的数据就都是纽约的行车记录了~ 需求 2（Group Agg） 计算搭载每种乘客数量的行车事件数，完成无限流上的聚合操作。也就是搭载1个乘客的行车数，搭载2个乘客的行车数。。12345SELECT psgCnt, COUNT(*) as cntFROM RidesGROUP BY psgCnt; 结果如下： 需求 3 （Window Agg） 为了持续地监测城市的交通流量，计算每个区域每 5 分钟的进入的车辆数。我们只关心纽约的区域交通情况，并且只关心至少有 5 辆车子进入的区域。这里我们还需要区域相关的 UDF ToAreaId12345678910111213public class ToAreaId extends ScalarFunction &#123; public int eval(float lon, float lat) &#123; return GeoUtils.mapToGridCell(lon, lat); &#125; public static int mapToGridCell(float lon, float lat) &#123; int xIndex = (int) Math.floor((Math.abs(LON_WEST) - Math.abs(lon)) / DELTA_LON); int yIndex = (int) Math.floor((LAT_NORTH - lat) / DELTA_LAT); return xIndex + (yIndex * NUMBER_OF_GRID_X); &#125;&#125; 具体的 SQL 如下：1234567891011SELECT toAreaId(lon,lat) AS area, TUMBLE_END(rideTime,INTERVAL '5' MINUTE) AS window_end, COUNT(*) AS cntFROM RidesWHERE isInNYC(lon,lat)GROUP BY toAreaId(lon,lat), isStart, TUMBLE(rideTime,INTERVAL '5' MINUTE)HAVING COUNT(*) &gt;= 5; 运行结果如下： 需求 4（write to Kafka） 将10分钟的搭乘的乘客数写入 Kafka结果表：Sink_TenMinPsgCnts具体的表结构定义如下： 具体的 SQL 如下（因为Sink_TenMinPsgCnts表的 cnt 是 Long 类型需要将 sum 的 cnt 也进行一下转换）：1234567INSERT INTO Sink_TenMinPsgCntsSELECT TUMBLE_START(rideTime,INTERVAL '10' MINUTE) AS cntStart, TUMBLE_END(rideTime,INTERVAL '10' MINUTE) AS cntEnd, CAST(SUM(psgCnt) AS BIGINT) AS cntFROM RidesGROUP BY TUMBLE(rideTime,INTERVAL '10' MINUTE); 执行docker-compose exec sql-client /opt/kafka-client/bin/kafka-console-consumer.sh --bootstrap-server kafka:9092 --topic TenMinPsgCnts --from-beginning可以监听到写入到 Kafka 中的数据，结果如下： 需求 5（write to ES） 从每个区域出发的行车数，写入到 ES结果表：Sink_AreaCnts具体的表结构定义如下：具体的 SQL 如下：123456INSERT INTO Sink_AreaCntsSELECT toAreaId(lon, lat) AS areaId, COUNT(*) AS cntFROM RidesGROUP BY toAreaId(lon, lat); 之后访问 http://localhost:9200/area-cnts 可以发现index已经创建了12345678910111213141516171819202122232425262728293031&#123; \"area-cnts\":&#123; \"aliases\":&#123; &#125;, \"mappings\":&#123; \"areacnt\":&#123; \"properties\":&#123; \"areaId\":&#123; \"type\":\"long\" &#125;, \"cnt\":&#123; \"type\":\"long\" &#125; &#125; &#125; &#125;, \"settings\":&#123; \"index\":&#123; \"creation_date\":\"1557219999010\", \"number_of_shards\":\"5\", \"number_of_replicas\":\"1\", \"uuid\":\"CXFqtgHqQyWi1SoUCicJWA\", \"version\":&#123; \"created\":\"6030199\" &#125;, \"provided_name\":\"area-cnts\" &#125; &#125; &#125;&#125; 可以通过 ES 简单的做一下查询 http://localhost:9200/area-cnts/_search?q=areaId:497911234567891011121314151617181920212223242526&#123; \"took\":62, \"timed_out\":false, \"_shards\":&#123; \"total\":5, \"successful\":5, \"skipped\":0, \"failed\":0 &#125;, \"hits\":&#123; \"total\":1, \"max_score\":1, \"hits\":[ &#123; \"_index\":\"area-cnts\", \"_type\":\"areacnt\", \"_id\":\"49791\", \"_score\":1, \"_source\":&#123; \"areaId\":49791, \"cnt\":18 &#125; &#125; ] &#125;&#125; 其他更多的实践可以去官方 wiki 查看学习，其他 Flink 的公开课可以去B站学习~，后面有机会我整理下自己学习 Flink 的相关资源，随缘更新哈。","categories":[{"name":"Flink","slug":"Flink","permalink":"http://yoursite.com/categories/Flink/"}],"tags":[]},{"title":"大数据介绍-MapReduce（下）","slug":"20190416-bigdata","date":"2019-04-16T08:52:44.000Z","updated":"2019-04-16T08:37:32.420Z","comments":true,"path":"2019/04/16/20190416-bigdata/","link":"","permalink":"http://yoursite.com/2019/04/16/20190416-bigdata/","excerpt":"书接上回","text":"书接上回 MapReduce系统架构 Master&amp;Worker Master Data Structure Map Tasks&amp;Worker Reduce Tasks&amp;Worker Master&amp;Worker 用户提交任务到调度系统 实现 Map 和 Reduce 程序 指定 Map Tasks 的数量 M 指定 Reduce Tasks 的数量 R Map 和 Reduce 被 copy 到集群机器上开始运行 其中一个配置特殊的程序为 Master，其他为 Worker 由 Master 分配 Map 或 Reduce Task 到空闲 Worker 所有任务完成后，唤醒用户程序（比如客户端） 输出结果包含 R 个文件，文件名由用户指定 Master Data Structure 对每个 Map 或 Reduce Task，存储了其状态和机器信息 状态包括：Idle，In-Progress，Complete 对每个已完成的 Map Task，存储其（R个）输出在 GFS 中的位置（Index） Map Tasks&amp;Worker 将输入数据解析成键值对 执行 Map 过程 Map 的输出结果最开始被存在内存的 Buffer 中 定时将 Buffer 中的键值对写入本地磁盘，并划分为 R 块 将 R 个输出文件的位置发给 Master Reduce Tasks&amp;Worker 被 Master 通知 Map 任务完成，并从 Master 那里得到了输出文件的位置后，通过 RPC 从 Map Task 执行的机器获取数据 读入数据后，进行排序 多个 Map Task 结果回到一个 Reduce Task，大量的重复 Key 需要排序合并 若数据过大无法全部读入内存，则使用外部排序 遍历数据，依次输入 Reduce 进行处理 输出被 append 到最终的输出文件中（一般是一个文件） 技术细节 选择 M 和 R 容错机制 充分利用本地存储 确定性与非确定性 选择 M 和 R 调度时间复杂度 O(M + R) 状态存储空间复杂度 O(M x R) 每组 Map Task 输出对应 R 个 Reduce Task ，因此是 M x R M: 远大于机器数量 细粒度意味着更好的 load balance R: 机器数量的几倍 大块数据重计算不利于失败恢复 容错机制 Master Failure Worker Failure Stragglers &amp; Backup Tasks Crashes, etc Master Failure Master 定时写 checkpoints ，通过其数据结构保存运行状态 Master 机器 down 掉之后就重启读 checkpoints 由于 Master 机器一般会选性能好的，不容易 down 掉，所以 down 的任务就重新跑一边 Worker Failure Master 通过向 Worker 发送心跳信号来确认其状态 一定时间无回应 -&gt; 假设 Failure 发生了 Map Task 失败了 Completed 和 In-Progress 的 Map Task 会被设置成 idle 分配给其他 Worker 重执行，因为原机器 down 了，数据存在本地获取不到 Reduce Task 失败了 In-Progress 的 Reduce Task 置 idle 重执行 Completed 的 Reduce Task 不重执行，因为不止存本地，还同步到了 GFS Stragglers &amp; Backup Tasks Stragglers：个别收尾任务的机器由于故障而变慢，拖慢整个任务完成 大量可恢复错误 同时运行太多其他任务，资源紧缺 解决方案：Backup Tasks 在整个 MR 任务即将完成时，Master 备份运行中的任务到空闲 Worker 只要其中一个完成了，就标记为 Completed 会耗费额外的计算资源，但能显著减少运行时间 Crashes, etc 数据格式错误 第三方代码 bug 解决方案：可以通过配置，跳过一定数量的 Segment fault 类会导致程序崩掉的数据 确定性与非确定性 确定性：同一输入，多次运行，行为与结果不变 非确定性：同一输入，多次运行，会有多种不同的行为或结果 确定性 分布式实现的过程和顺序执行的过程和产出的结果一样 保证：一个特定的 Reduce Task 与一些特定的顺序操作等价 但是：不同 Reduce Task 的输出会对应不同的操作顺序 也就是说：无法用一个等价的顺序过程来代表所有 Reduce Task Spark VS MapReduce前面也提到了 Spark 那这里做一下简单的比较吧 Spark 把运算的中间数据存在内存，迭代计算效率更高，MapReduce 的中间结果需要落地要存到磁盘，性能会差很多 Spark 有更加完善的容错机制，它通过弹性分布式数据集 RDD 来实现高效容错，RDD 是一组分布式的存储在节点内存中的只读性质的数据集，这些集合是弹性的，某一部分丢失或者出错，可以通过整个数据集的计算流程的血缘关系来实现重建，MapReduce 出现错误只能重新计算，成本较高 Spark 更加通用，Spark 提供了 transformation 和 action 这两大类的多个功能 API ，另外还有流式处理，Spark Streaming 模块、图计算 Graph X 等，MapReduce 只提供了 Map 和 Reduce 两种操作，流计算以及其他模块的支持比较缺乏 Spark 框架和生态更为复杂，首先有 RDD 、血缘 lineage、执行时的有向无环图 DAG、stage 划分等等，很多时候 Spark 任务需要根据不同业务场景的需要进行调优已达到性能要求，MapReduce 框架及其生态相对简单，对性能的要求也相对较弱，但运行稳定，适合长期后台运行","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/大数据/"}],"tags":[{"name":"MapReduce","slug":"MapReduce","permalink":"http://yoursite.com/tags/MapReduce/"}]},{"title":"大数据介绍-MapReduce（上）","slug":"20190409-bigdata","date":"2019-04-10T14:52:44.000Z","updated":"2019-04-16T08:33:54.010Z","comments":true,"path":"2019/04/10/20190409-bigdata/","link":"","permalink":"http://yoursite.com/2019/04/10/20190409-bigdata/","excerpt":"今天下班接了两个拼车的小哥，两个人好像都是做数据开发的，一上车他们两个就聊了起来，情况大概是这样的。。。。","text":"今天下班接了两个拼车的小哥，两个人好像都是做数据开发的，一上车他们两个就聊了起来，情况大概是这样的。。。。 大数据背景此时路过一位精通某数据处理语言的大佬 Python Spark 单机 多机 单线程 多核 小数据集 超大数据集 并行思想计算过程能被划分 n 个单元 通过线程充分利用处理器 MapReduce介绍 一个 Google 设计的范式及其相关计算架构的实现 范式：让针对分布式问题（或其子集）的编程更简单 灵感来自于函数式编程语言（Lisp） 能够表达几乎所有的计算模型 系统：自动化的数据分布、并行计算以及结果聚合 输入数据的拆分 集群程序执行的调度 处理机器宕机 处理机器间通信 限制数据交互的形式以杜绝加锁（无共享状态=无锁） MapReduce定义MapReduce 过程将一系列输入的键值对转化为输出键值对 MapReduce (k1,v1) -&gt; (k3,v3) 由 Map Function 和 Reduce Function 组成，具体实现由开发者定义 Map 输入为一个键值对，输出为一个中间键值对 Map（k1,v1）-&gt; list(k2,v2) Reduce 输入为中间键值对，过程中将输入值合并，输出为一个（更小的）数据集合（通常输出为 0 或者 1 个数值） Reduce（k2，list（v2））-&gt;list（v3） 中间过程（Shuffle）：MapReduce 会将 Map 产生的有相同键的中间建值收集起来，通过迭代器依次传给 Reduce MapReduce WordCount Map：输入为 &lt;文件名 ：文件内容&gt; 的键值对，中间通过顺序读取和分词，产出 &lt;单词 ：个数&gt; 的键值对 Shuffle：读取、收集 Mapper 产出的单词相同的键值对并将其对应值合并为 List ，发给 Reducer Reduce： 输入为 &lt;单词 ：个数列表&gt; 的键值对，中间进行加和统计，输出统计结果 MapReduce：最终输出为 &lt;单词 ：总个数&gt; 的键值对 处理过程 Input Handling Map Function Compare Function Partition Function Reduce Function Output Writer Input Handling 用户定义格式，输入数据分成 M 份每份 16MB 到 64MB 大小 分发 Map 和 Reduce 程序到机器集群 分发任务到空闲 Worker Map Function 用户定义过程 输入：Key，Value Pair 输出：List of Key ，Value Pairs Compare Function 为输入到 Reduce 中的数据（键值对中的值）排序为什么要排序？ 看起来舒服，输入数据中的词是按 a-z 排列的，debug方便 方便查找，二分查找+有序数据=爽（但是数据太大还是无法在内存中search） Map 的结果中 Key 重复较多，不一定被严格合并在一起，通过排序、合并之后的数据也方便 Reduce 来处理（例如一篇文章中的 the 可能出现很多次） Partition Function&amp;Reduce FunctionPartition Function 分配 Map 的结果到特定的 Reduce 输入：Key，Reduce 的个数 输出：特定 Reduce 的索引 通常是 hash(key)%Reduce 的个数 Reduce Function 用户定义过程 输入：Key，Sorted list of values 输出：0 或者 1个 Value （或者 List ，但是一般不需要） O(n) 输入到 Reduce 中的数据量还是很庞大，因此 Reduce Function 的空间复杂度最好是 O(1)，这在大数据处理中很重要。时间复杂度需要做到尽可能的优化。 Output Writer 将结果写入到存储（如：GFS，HDFS，ETC） 输出文件数量一般和 Reduce 数量一致 因为可能作为下一个 MapReduce 过程的输入，一般是不需要进行合并 系统架构 Master&amp;Worker Master Data Structure Map Tasks&amp;Worker Reduce Tasks&amp;Worker 明天还要出车，架构和对比放到下期再说吧。。。","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/大数据/"}],"tags":[{"name":"MapReduce","slug":"MapReduce","permalink":"http://yoursite.com/tags/MapReduce/"}]},{"title":"流式处理","slug":"20190407-stream","date":"2019-04-07T15:55:44.000Z","updated":"2019-04-10T14:49:55.158Z","comments":true,"path":"2019/04/07/20190407-stream/","link":"","permalink":"http://yoursite.com/2019/04/07/20190407-stream/","excerpt":"小张今天下班时间在软件园拉了两位程序猿小哥，一路上他们都在谈『大数据』『流处理』『实时计算』『Flink』，拉过这么多程序猿只听说过『离线处理』『Hadoop』『Hive』，还是头一次听说这个『流式处理』，于是跑完这一单小张赶紧回到家，打开电脑百度了起来。。。。","text":"小张今天下班时间在软件园拉了两位程序猿小哥，一路上他们都在谈『大数据』『流处理』『实时计算』『Flink』，拉过这么多程序猿只听说过『离线处理』『Hadoop』『Hive』，还是头一次听说这个『流式处理』，于是跑完这一单小张赶紧回到家，打开电脑百度了起来。。。。 传统的批次处理方法 介绍 流处理 介绍 有状态流处理的挑战 有状态 分布式 乱序 容错 传统的批次处理方法 介绍 在介绍流式处理引擎之前我们先简单的说明一下传统的批次处理方法，一般传统的批处理离不开以下的三个概念： 持续收集 以时间作为划分数个批次的数据 周期性执行批次运算 但是批处理在某些场景还是不够优雅，例如： 计算每小时特定事件转换的次数（如每小时 用户状态从 A-&gt;B 的次数）这种情况如果我们是按一个小时来划分批次， 3:55 出现了用户状态 A ，但是到了 4:05 才出现了用户状态 B 。这时候必须把 A 状态作为中介状态带到 B 的这个批次。 虽然 Spark 已经有了 Micro Batching 模式，实现连续不断的批进行计算来模拟流处理，当批能足够小就可以做到很低的延迟，可以在一定程度上满足实时计算的场景，但是这种攒批过程还是会存在延迟，无法做到真正的流处理。 流处理 介绍 自然流数据都是一条，一条的流入，计算的形式是每条数据到来都进行计算，这种计算模式能自然地做到低延迟。所以流处理主要有两个概念： 数据是无界的 基于一条一条的数据驱动计算，没有人为的去触发 有状态流处理的挑战 有状态 是否有办法累积维护状态 在进行实时数据计算的时候可能存在许多的中间状态，例如我们想看用户选购商品的时候在下单前都浏览了哪些商品，这时我们就需要维护用户在下单前浏览的所有商品数据。 是否有办法支撑维护大量的状态 在实际的业务中可能存在大量中间状态的数据，当这些状态的数据大到单个机器内存无法支撑，能否有办法对这些数据进行合理的存储。 是否有办法判断该收集的数据都已经收集完了 分布式 在分布式的情况下如何保证相同类型的数据被发送到同一个分区。例如：统计用户行为，需要将同一个用户的数据放到同一个分区进行处理。 乱序 在实际的流式计算中数据到来的顺序有时会对计算结果有很大的影响，例如：我们对一个每 10s 的窗口进行计算这时有在 9s 时的数据延迟了，落在了下一个窗口，那么无疑是对计算的结果有影响的。 容错 在计算过程中因为机器或者网络的原因导致处理失败了 是否能做到快速的恢复正常 是否能保证数据的不丢失 是否能保证数据不重复处理 因为在流处理中，数据会源源不断的流入，每条数据都会触发计算，并且延迟基本都是毫秒级想做到快速恢复正常，和数据不出现错误处理，也就是保证 Exactly-Once，这时相当困难的。 当然想要做成流处理引擎不止以上这几点挑战！ 百度完的小张挠了挠头，想着做到流处理也忒难了，这可咋整啊，纳闷时看了看时间已经十二点了，“算了，先睡觉”，小张合上了电脑躺在床上刷起了微博，感觉自己离成为程序猿又进了一步，躺在床上“今天那两小哥说的『实时计算』『Flink』是什么来着，算了算了，先看会蔡徐坤运球”","categories":[{"name":"流计算","slug":"流计算","permalink":"http://yoursite.com/categories/流计算/"}],"tags":[{"name":"流计算","slug":"流计算","permalink":"http://yoursite.com/tags/流计算/"},{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/大数据/"}]},{"title":"读书读书读书","slug":"20180814-read","date":"2018-08-14T12:47:44.000Z","updated":"2019-04-05T14:27:58.000Z","comments":true,"path":"2018/08/14/20180814-read/","link":"","permalink":"http://yoursite.com/2018/08/14/20180814-read/","excerpt":"最近读书技巧总结 封面id70171811","text":"最近读书技巧总结 封面id70171811 最近看了不少书，稍微总结了些小经验吧，主要就是用思维导图，这里推荐下xmind。 具体操作如下。。。 先大体浏览一遍目录，然后把书的主要脉络搞清楚，列出大体的架构 粗读一遍评记忆写一下章节的重要信息 精读然后对内容做补充 个人认为还是比较有作用的，之前读书都是读完下段忘上段，现在做了思维导图后，哦豁，清晰的一匹还方便复习2333","categories":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/categories/日常/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]},{"title":"区块链学习","slug":"20180809-区块链学习","date":"2018-08-09T13:47:44.000Z","updated":"2019-04-05T14:27:43.000Z","comments":true,"path":"2018/08/09/20180809-区块链学习/","link":"","permalink":"http://yoursite.com/2018/08/09/20180809-区块链学习/","excerpt":"最近忙着公司的工作好久没有更新博客了真是怠惰，因为公司在做关于区块链的项目最近也是补充了下自己的技术栈，就用这个帖子记录一些不错的博文吧。封面id:70059820","text":"最近忙着公司的工作好久没有更新博客了真是怠惰，因为公司在做关于区块链的项目最近也是补充了下自己的技术栈，就用这个帖子记录一些不错的博文吧。封面id:70059820 1、 比特币白皮书 万恶之源=。=2、 区块链入门教程：阮一峰3、 比特币入门教程：阮一峰4、 加密货币的本质：阮一峰5、 区块链技术指南6、 Node.js区块链开发7、 端对端加密通讯协议Signal protocol 相关的内容还会补充，希望能通过这个项目能对区块链有更深刻的了解。\u0000\u0000\b\u0000\u0000","categories":[{"name":"区块链","slug":"区块链","permalink":"http://yoursite.com/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://yoursite.com/tags/区块链/"},{"name":"加密算法","slug":"加密算法","permalink":"http://yoursite.com/tags/加密算法/"}]},{"title":"Vue操作dom遇到的问题","slug":"20180802-vue操作dom出现的问题","date":"2018-08-02T12:29:44.000Z","updated":"2019-04-05T14:28:48.000Z","comments":true,"path":"2018/08/02/20180802-vue操作dom出现的问题/","link":"","permalink":"http://yoursite.com/2018/08/02/20180802-vue操作dom出现的问题/","excerpt":"vue操作dom遇到的坑","text":"vue操作dom遇到的坑 刚搞Vue没多久在使用mounted的时候遇到了类似这样的问题具体的代码如下: 12345678910111213141516171819let vm = new Vue(&#123; el: '#app', data: &#123;radio: 'home'&#125;, mounted()&#123; console.log(this.$refs.child.$el.innerHTML); &#125;, components:&#123; child:&#123; template: '#child', data()&#123; return &#123;arr:[1,2,3]&#125; &#125;, mounted() &#123; this.arr = [4, 5, 6]; &#125; &#125; &#125; &#125;); 看了下api了解子组件 this.arr = [4, 5, 6];此处是异步渲染dom，父组件中this.$refs.child.$el.innerHTML此处的dom还没有渲染，因此导致了上面那种情况，所以为了保证dom渲染完毕需要用到生命周期方法$nextTick保证dom渲染完成 修改后的代码如下12345678910111213141516171819202122 let vm = new Vue(&#123; el: '#app', data: &#123;radio: 'home'&#125;, mounted()&#123;//保证dom渲染$nextTick 想操作dom 就加一个nextTick this.$nextTick(()=&gt;&#123; console.log(this.$refs.child.$el.innerHTML);//此处dom还没有渲染 &#125;) &#125;, components:&#123; child:&#123; template: '#child', data()&#123; return &#123;arr:[1,2,3]&#125; &#125;, mounted() &#123; this.arr = [4, 5, 6];//此处是异步渲染dom &#125; &#125; &#125; &#125;);&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Nginx常见用法","slug":"20180709-Nginx常用方法","date":"2018-07-09T15:47:44.000Z","updated":"2019-04-05T14:27:22.000Z","comments":true,"path":"2018/07/09/20180709-Nginx常用方法/","link":"","permalink":"http://yoursite.com/2018/07/09/20180709-Nginx常用方法/","excerpt":"Nginx常见用法介绍以及简单配置","text":"Nginx常见用法介绍以及简单配置 1、静态HTTP服务器Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。配置： 123456server&#123; listen 80; //端口号 location / &#123; root /usr/share/nginx/html; //静态文件路径 &#125;&#125; 2、反向代理服务器反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 反向代理方式实际上就是一台负责转发的代理服务器，貌似充当了真正服务器的功能，但实际上并不是，代理服务器只是充当了转发的作用，并且从真正的服务器那里取得返回的数据。这样说，其实nginx 完成的就是这样的工作。我们让nginx监听一个端口，譬如80端口，但实际上我们转发给在8080端口的tomcat，由它来处理真正的请求，当请求完 成后，tomcat返回，但数据此时没直接返回，而是直接给nginx，由nginx进行返回，这里，我们会以为是nginx进行了处理，但实际上进行处 理的是tomcat。 配置：123456server&#123; listen 80; location / &#123; proxy_pass `http://192.168.20.1:8080`; //应用服务器地址 &#125;&#125; 既然服务器可以直接HTTP访问，为什么要在中间加上一个反向代理，不是多此一举吗？反向代理有什么作用？继续往下看，下面的负载均衡、虚拟主机，都基于反向代理实现，当然反向代理的功能也不仅仅是这些。 3、负载均衡当网站访问量非常大，网站站长开心赚钱的同时，也摊上事儿了。因为网站也来越慢，一台服务器已经不够用了。于是将相同的应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。同时带来的好处是，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 Nginx可以通过反向代理来实现负载均衡 配置：12345678910upstream myapp &#123; server 192.168.20.1:8080; //应用服务器1 server 192.168.20.2:8080; //应用服务器2&#125;sever &#123; listen 80; location / &#123; proxy_pass `http://myapp` &#125;&#125; 4、虚拟主机有的网站访问量大，需要负载均衡。然而并不是所有网站都如此出色，有的网站由于访问量太小，需要节省成本，将多个网站部署在同一台服务器上。 例如将www.aaa.com和www.bbb.com两个网站部署在同一台服务器上，两个域名解析到同一个IP地址，当时用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样，所以叫虚拟主机。 配置：12345678910111213141516171819server &#123; listen 80 default_server; server_name _; return 444;//过滤其他域名的请求，返回444状态码 &#125;server &#123; listen 80; server_name www.aaa.com; //www.aaa.com域名 location / &#123; proxy_pass `http://location:8080`; //对应端口8080 &#125;&#125; server &#123; listen 80; server_name www.bbb.com; //www.bbb.com location / &#123; proxy_pass `http://localhost:8081`;//对应端口号8081 &#125;&#125; 5、FastCGINginx本身不支持PHP等语言，但是它可以通过FastCGI来将请求扔给某些语言或框架处理（例如PHP、Python、Perl）。123456789server &#123; listen 80; location ~ \\.php$ &#123; include fastcgi_params; fastcgi_param SCRIPT_FILENAME /PHP文件路径$fastcgi_script_name; // PHP文件路径 fastcgi_pass 127.0.0.1:9000; // PHP-FPM地址和端口号 // 另一种方式：fastcgi_pass unix:/var/run/php5-fpm.sock; &#125;&#125; 配置中将.php结尾的请求通过FashCGI交给PHP-FPM处理，PHP-FPM是PHP的一个FastCGI管理器。有关FashCGI可以查阅其他资料，本文不再介绍。 fastcgi_pass和proxy_pass有什么区别？下面一张图带你看明白： 参考文献：叉叉哥的BLOG","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"redis高可用","slug":"20180703-redis哨兵模式","date":"2018-07-06T15:47:44.000Z","updated":"2019-04-05T14:27:17.000Z","comments":true,"path":"2018/07/06/20180703-redis哨兵模式/","link":"","permalink":"http://yoursite.com/2018/07/06/20180703-redis哨兵模式/","excerpt":"redis高可用 哨兵模式 封面id=69531858","text":"redis高可用 哨兵模式 封面id=69531858 一.简介Redis Sentinel是Redis官方提供的集群管理工具，可以部署在其他与redis集群可通讯的机器中监控redis集群。 二.特性 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。 三.哨兵作用(1).监控redis(master和slave)是否正常运行; (2).当master运行出现状况，能够通知另外一个进程自动将slave切换成master。 四.应用场景当使用redis做master-slave的高可用方案时，如果master宕机了，想自动进行主备切换，可以考虑使用哨兵模式。 五.windows配置高可用 高可用步骤一 启动多台redis服务，搭建redis主从复制 1.启动master用启动命名redis-server redis.windows.conf启动一个redis实例，该实例比如端口是6379，那么这个实例就是我们的master了。 2.配置slave复制一份redis.windows.conf，比如重命名为redis.windows.conf-6479修改redis.windows.conf-6479里的端口号，改为6479并且找到 #slaveof &lt;masterip&gt; &lt;masterport&gt; 在该行下写入 slaveof 127.0.0.1 6379 注意空格 顾名思义，意思就是该6479实例，是主机127.0.0.1下6379实例的从属改了这两处配置之后，启动该从的实例，命名如下redis-server redis.windows.conf-6479如下图，说明配置成功依照上述步骤，我们可以再复制 redis.windows.conf-6479，命名为redis.windows.conf-6579，并修改redis.windows.conf-6579里的端口改为6579，并用启动命名redis-server redis.windows.conf-6579启动6579的实例，这样就成了一主多从的模式 3.验证主从是否生效 用工具连接上这三个实例，比如我们在6379的主添加一个key，看下6479和6579两个从是否有同样的key生成，还有就是在6379的主删除一个key或者修改一个key，看两个从是否同步删除或更新。 高可用步骤二 配置哨兵 1.配置哨兵新建文件sentinel.conf-26379sentinel.conf-26479sentinel.conf-26579 分别写入以下5行配置，注意端口号分别是26379、26479、26579别的一样 12345port 26379sentinel monitor mymaster 127.0.0.1 6379 2sentinel down-after-milliseconds mymaster 60000sentinel failover-timeout mymaster 180000sentinel parallel-syncs mymaster 1 配置说明： port :当前Sentinel服务运行的端口 sentinel monitor mymaster 127.0.0.1 6379 2Sentinel去监视一个名为mymaster的主redis实例，这个主实例的IP地址为本机地址127.0.0.1，端口号为6379，而将这个主实例判断为失效至少需要2个 Sentinel进程的同意，只要同意Sentinel的数量不达标，自动failover就不会执行 sentinel down-after-milliseconds mymaster 60000指定了Sentinel认为Redis实例已经失效所需的毫秒数。当实例超过该时间没有返回PING，或者直接返回错误，那么Sentinel将这个实例标记为主观下线。只有一个 Sentinel进程将实例标记为主观下线并不一定会引起实例的自动故障迁移：只有在足够数量的Sentinel都将一个实例标记为主观下线之后，实例才会被标记为客观下线，这时自动故障迁移才会执行 sentinel failover-timeout mymaster 180000如果在该时间（ms）内未能完成failover操作，则认为该failover失败 sentinel parallel-syncs mymaster 1 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长 2. 启动三个哨兵命令是redis-server sentinel.conf-26379 –sentinelredis-server sentinel.conf-26479 –sentinelredis-server sentinel.conf-26579 –sentinel 3.哨兵大致原理图意思大致就是主实例挂了之后，会将一个从实例提升为主实例，从而实现高可用 PS：这是windows单机模式下的redis哨兵模式，不过分布式环境下原理也差不多Linux环境下搭建可以参考这两篇文章：如何搭建Redis的主从复制Redis的哨兵模式 对了最近看了这部电影，安利一下~.hexo-image-steam-lazy {display:block;}.hexo-img-stream{width:90%;max-width:1100px;margin:3% auto}div.hexo-img-stream figure{background:#fefefe;box-shadow:0 1px 2px rgba(34,25,25,0.4);margin:0 0.05% 3%;padding:3%;padding-bottom:10px;display:inline-block;max-width:25%}div.hexo-img-stream figure img{border-bottom:1px solid #ccc;padding-bottom:15px;margin-bottom:5px}div.hexo-img-stream figure figcaption{font-size:.9rem;color:#444;line-height:1.5;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}div.hexo-img-stream small{font-size:1rem;float:right;text-transform:uppercase;color:#aaa}div.hexo-img-stream small a{color:#666;text-decoration:none;transition:.4s color}@media screen and (max-width:750px){.hexo-img-stream{column-gap:0}}我不是药神 $('img.hexo-image-steam-lazy').lazyload({ effect:'fadeIn' });\u0000\u0000\b\u0000","categories":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"Transactional注解讲解","slug":"20180627-TransactionDefinition接口特性","date":"2018-06-27T12:47:44.000Z","updated":"2019-04-05T14:27:12.000Z","comments":true,"path":"2018/06/27/20180627-TransactionDefinition接口特性/","link":"","permalink":"http://yoursite.com/2018/06/27/20180627-TransactionDefinition接口特性/","excerpt":"Transactional注解讲解","text":"Transactional注解讲解 在需要事务管理的地方加@Transactional 注解。 @Transactional 注解只能应用到接口方法、类、还有public方法上。 12345678910111213 @Override@Transactionalpublic SysUser saveUser(UserDto userDto) &#123; SysUser user = userDto; user.setPassword(passwordEncoder.encode(user.getPassword())); user.setStatus(SysUser.Status.VALID); userDao.save(user); saveUserRoles(user.getId(), userDto.getRoleIds()); log.debug(\"新增用户\", user.getUsername()); return user;&#125; 属性 类型 描述 value String 可选的限定描述符，指定使用的事务管理器 propagation enum: Propagation 可选的事务传播行为设置 isolation enum: Isolation 可选的事务隔离级别设置 readOnly boolean 读写或只读事务，默认读写 timeout int (in seconds granularity) 事务超时时间设置 rollbackFor Class对象数组，必须继承自Throwable 导致事务回滚的异常类数组 rollbackForClassName 类名数组，必须继承自Throwable 导致事务回滚的异常类名字数组 noRollbackFor Class对象数组，必须继承自Throwable 不会导致事务回滚的异常类数组 noRollbackForClassName 类名数组，必须继承自Throwable 不会导致事务回滚的异常类名字数组 TransactionDefinition接口特性：事务隔离级别隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。 TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 事务传播行为所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot jwt redis方式实现登录存储","slug":"20180625-Spring Boot JWT Redis方式实现","date":"2018-06-25T12:47:44.000Z","updated":"2019-04-05T14:27:07.000Z","comments":true,"path":"2018/06/25/20180625-Spring Boot JWT Redis方式实现/","link":"","permalink":"http://yoursite.com/2018/06/25/20180625-Spring Boot JWT Redis方式实现/","excerpt":"Spring Boot jwt redis方式实现登录存储","text":"Spring Boot jwt redis方式实现登录存储 JWT Redis方式实现1、Token dto1234567891011121314151617181920212223242526272829public class Token implements Serializable &#123; private static final long serialVersionUID = 6314027741784310221L; private String token; //登录时间戳 private Long loginTime; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; public Long getLoginTime() &#123; return loginTime; &#125; public void setLoginTime(Long loginTime) &#123; this.loginTime = loginTime; &#125; public Token(String token, Long loginTime) &#123; super(); this.token = token; this.loginTime = loginTime; &#125; 2、LoginUser Dto12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class LoginUser extends SysUser implements UserDetails &#123; private static final long serialVersionUID = -1379274258881257107L; private List&lt;Permission&gt; permissions; private String token; //登录时间戳（毫秒） private Long LoginTime; //过期时间戳 private Long expireTime; public List&lt;Permission&gt; getPermissions() &#123; return permissions; &#125; public void setPermissions(List&lt;Permission&gt; permissions) &#123; this.permissions = permissions; &#125; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; public Long getLoginTime() &#123; return LoginTime; &#125; public void setLoginTime(Long loginTime) &#123; LoginTime = loginTime; &#125; public Long getExpireTime() &#123; return expireTime; &#125; public void setExpireTime(Long expireTime) &#123; this.expireTime = expireTime; &#125; @Override @JsonIgnore //返回的json数据即不包含该属性 public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return permissions.parallelStream().filter(p -&gt; !StringUtils.isEmpty(p.getPermission())) .map(p -&gt; new SimpleGrantedAuthority(p.getPermission())).collect(Collectors.toSet()); &#125; public void setAuthorities(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; // do nothing &#125; /** * 判断账号是否过期 * @return */ @Override @JsonIgnore public boolean isAccountNonExpired() &#123; return true; &#125; /** * 判断账号是否锁定 * @return */ @Override @JsonIgnore public boolean isAccountNonLocked() &#123; return getStatus() != Status.LOCKED; &#125; /** * 判断密码是否过期 * @return */ @Override @JsonIgnore public boolean isCredentialsNonExpired() &#123; return true; &#125; /** * 判断账号是否激活 * @return */ @Override public boolean isEnabled() &#123; return true; &#125; &#125; 3、TokenServiceJwtImpl这里主要是逻辑实现 详细说明一下 jwt的构成【转】原文地址第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)。 header jwt的头部承载两部分信息： 声明类型，这里是jwt 声明加密的算法 通常直接使用 HMAC SHA256 完整的头部就像下面这样的JSON： { “typ”: “JWT”, “alg”: “HS256” } 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 playload 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 标准中注册的声明 公共的声明 私有的声明 标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密. 私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 定义一个payload： { “name”:”Free码农”, “age”:”28”, “org”:”今日头条” } 然后将其进行base64加密，得到Jwt的第二部分： eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9 signature jwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分： 49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY 密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。 具体实现这里我们从配置文件中获取token的过期秒数和私钥。设置一个字符串LOGIN_USER_KEY作为找到登录用户的凭证123456789101112131415//token过期秒数@Value(\"$&#123;token.expire.seconds&#125;\")private Integer expireSeconds;@Autowiredprivate RedisTemplate&lt;String, LoginUser&gt; redisTemplate;@Autowiredprivate SysLogService logService;//私钥@Value(\"$&#123;token.jwtSecret&#125;\")private String jwtSecret;private static Key KEY = null;private static final String LOGIN_USER_KEY = \"LOGIN_USER_KEY\"; 按照上文所说的加密方式进行加密生成token12345678910private String createJWTToken(LoginUser loginUser)&#123; Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(LOGIN_USER_KEY, loginUser.getToken());// 放入一个随机字符串，通过该串可找到登录用户 String jwtToken = Jwts.builder().setClaims(claims).signWith(SignatureAlgorithm.HS256, getKeyInstance()) .compact(); return jwtToken;&#125; 12345678910111213private Key getKeyInstance() &#123; if (KEY == null) &#123; synchronized (TokenServiceJwtImpl.class) &#123; if (KEY == null) &#123;//双重锁 byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(jwtSecret); KEY = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName()); &#125; &#125; &#125; return KEY;&#125; 将登录用户信息储存到redis中123456private void cacheLoginUser(LoginUser loginUser) &#123; loginUser.setLoginTime(System.currentTimeMillis()); loginUser.setExpireTime(loginUser.getLoginTime() + expireSeconds * 1000); //根据uuid将loginUser缓存 redisTemplate.boundValueOps(getTokenKey(loginUser.getToken())).set(loginUser,expireSeconds, TimeUnit.SECONDS);&#125; 之后我们可以根据token从redis获取登录用户的信息，进行判断用户登录是否过期等操作。","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/categories/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Security实现登录功能和原理","slug":"20180623-spring security登录及实现原理","date":"2018-06-23T12:47:44.000Z","updated":"2019-04-05T14:26:48.000Z","comments":true,"path":"2018/06/23/20180623-spring security登录及实现原理/","link":"","permalink":"http://yoursite.com/2018/06/23/20180623-spring security登录及实现原理/","excerpt":"写了几篇前端的东西差点忘了我是个写后台的。。这次我们来讲一下Spring Security实现登录功能和原理（基于springboot+jwt），之前一直会用Spring Security但是对它的认证机制很是懵逼，最近看了源码才豁然开朗。如果需要源码可以留下邮箱。ps：篇幅较长，建议找个舒适的姿势看，不然就会像老夫一样歪着脖子看世界杯到现在还脖子痛。","text":"写了几篇前端的东西差点忘了我是个写后台的。。这次我们来讲一下Spring Security实现登录功能和原理（基于springboot+jwt），之前一直会用Spring Security但是对它的认证机制很是懵逼，最近看了源码才豁然开朗。如果需要源码可以留下邮箱。ps：篇幅较长，建议找个舒适的姿势看，不然就会像老夫一样歪着脖子看世界杯到现在还脖子痛。 spring security的配置SecurityConfig 配置文件12345678910111213141516171819202122232425262728@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //跨站请求伪造禁用 http.csrf().disable(); // 基于token，所以不需要session http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); //不需要校验的文件 http.authorizeRequests() .antMatchers(\"/\", \"/*.html\", \"/favicon.ico\", \"/css/**\", \"/js/**\", \"/fonts/**\", \"/layui/**\", \"/img/**\", \"/v2/api-docs/**\", \"/swagger-resources/**\", \"/webjars/**\", \"/pages/**\", \"/druid/**\", \"/statics/**\") .permitAll().anyRequest().authenticated(); http.formLogin().loginPage(\"/login.html\").loginProcessingUrl(\"/login\") .successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler).and() .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint); http.logout().logoutUrl(\"/logout\").logoutSuccessHandler(logoutSuccessHandler); // 解决不允许显示在iframe的问题 http.headers().frameOptions().disable(); http.headers().cacheControl(); http.addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class);&#125;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());&#125; SecurityHandlerConfig（spring security处理器）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 登陆成功，返回token * */@Beanpublic AuthenticationSuccessHandler loginSuccessHandler() &#123; return new AuthenticationSuccessHandler() &#123; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Token token = tokenService.saveToken(loginUser); ResponseUtil.responseJson(httpServletResponse, HttpStatus.OK.value(),token); &#125; &#125;;&#125;/** * 登录失败 */@Beanpublic AuthenticationFailureHandler loginFailureHandler() &#123; return new AuthenticationFailureHandler() &#123; @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; String msg = null; if (e instanceof BadCredentialsException) &#123; msg = \"密码错误\"; &#125; else &#123; msg = e.getMessage(); &#125; ResponseInfo info = new ResponseInfo(HttpStatus.UNAUTHORIZED.value() + \"\", msg); ResponseUtil.responseJson(httpServletResponse, HttpStatus.UNAUTHORIZED.value(), info); &#125; &#125;;&#125;/** * 未登录 */@Beanpublic AuthenticationEntryPoint authenticationEntryPoint() &#123; return new AuthenticationEntryPoint() &#123; @Override public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; ResponseInfo info = new ResponseInfo(HttpStatus.UNAUTHORIZED.value() + \"\", \"请先登录\"); ResponseUtil.responseJson(httpServletResponse, HttpStatus.UNAUTHORIZED.value(), info); &#125; &#125;;&#125;/** * 退出处理 */@Beanpublic LogoutSuccessHandler logoutSuccessHandler() &#123; return new LogoutSuccessHandler() &#123; @Override public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; ResponseInfo info = new ResponseInfo(HttpStatus.OK.value() + \"\", \"退出成功\"); String token = TokenFilter.getToken(httpServletRequest); tokenService.deleteToken(token); ResponseUtil.responseJson(httpServletResponse,HttpStatus.OK.value(),info); &#125; &#125;;&#125; Token拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Componentpublic class TokenFilter extends OncePerRequestFilter &#123; private static final String TOKEN_KEY = \"token\"; private static final Long MINUTES_10 = 10 * 60 * 1000L; @Autowired private TokenService tokenService; @Autowired private UserDetailsService userDetailsService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String token = getToken(request); if (StringUtils.isBlank(token)) &#123; LoginUser loginUser = tokenService.getLoginUser(token); if (loginUser != null) &#123; loginUser = checkLoginTime(loginUser); UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities()); SecurityContextHolder.getContext().setAuthentication(authenticationToken); &#125; &#125; filterChain.doFilter(request,response); &#125; /** * 校验过期时间 * 过期时间与当前时间对比，临近过期10分钟的话，自动刷新缓存 * * @return */ private LoginUser checkLoginTime(LoginUser loginUser) &#123; long expireTime = loginUser.getExpireTime(); long currentTime = System.currentTimeMillis(); if (expireTime - currentTime &lt;= MINUTES_10) &#123; String token = loginUser.getToken(); loginUser = (LoginUser) userDetailsService.loadUserByUsername(loginUser.getUsername()); loginUser.setToken(token); tokenService.refresh(loginUser); &#125; return loginUser; &#125; /** * 根据参数或者header获得token * @param request * @return */ public static String getToken(HttpServletRequest request) &#123; String token = request.getParameter(TOKEN_KEY); if (StringUtils.isBlank(token)) &#123; token = request.getHeader(TOKEN_KEY); &#125; return token; &#125;&#125; 具体实现1、前端调用登录方法123456789101112131415161718192021222324252627function login(obj) &#123; $(obj).attr(\"disabled\", true); var username = $.trim($('#username').val()); var password = $.trim($('#password').val()); if (username == \"\" || password == \"\") &#123; $(\"#info\").html('用户名或者密码不能为空'); $(obj).attr(\"disabled\", false); &#125; else &#123; $.ajax(&#123; type : 'post', url : '/login', data : $(\"#login-form\").serialize(), success : function(data) &#123; localStorage.setItem(\"token\", data.token); location.href = '/index.html'; &#125;, error : function(xhr, textStatus, errorThrown) &#123; var msg = xhr.responseText; var response = JSON.parse(msg); $(\"#info\").html(response.message); $(obj).attr(\"disabled\", false); &#125; &#125;); &#125;&#125; 2、我们在SecurityConfig 配置文件中的这段代码设置了对登录的处理。123http.formLogin().loginPage(\"/login.html\").loginProcessingUrl(\"/login\") .successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler).and() .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint); 3、后经过org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter这个拦截器的attemptAuthentication方法获取到前端的用户名和密码，具体的代码如下123456789101112131415161718192021222324public UsernamePasswordAuthenticationFilter() &#123; super(new AntPathRequestMatcher(\"/login\", \"POST\")); &#125; public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (this.postOnly &amp;&amp; !request.getMethod().equals(\"POST\")) &#123; throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod()); &#125; else &#123; String username = this.obtainUsername(request); String password = this.obtainPassword(request); if (username == null) &#123; username = \"\"; &#125; if (password == null) &#123; password = \"\"; &#125; username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125; &#125; 4、上面的方法只支持post请求，获取到用户名密码后构造未认证的UsernamePasswordAuthentication 后设置details然后通过AuthenticationManager（实际上为ProviderManager的authenticate方法）完成验证，该方法先循环遍历provider 找到具体执行该认证的provider 然后复制details 然后由具体的provider来完成认证，具体代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); AuthenticationException lastException = null; Authentication result = null; boolean debug = logger.isDebugEnabled(); Iterator var6 = this.getProviders().iterator(); while(var6.hasNext()) &#123; AuthenticationProvider provider = (AuthenticationProvider)var6.next(); if (provider.supports(toTest)) &#123; if (debug) &#123; logger.debug(\"Authentication attempt using \" + provider.getClass().getName()); &#125; try &#123; result = provider.authenticate(authentication); if (result != null) &#123; this.copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException var11) &#123; this.prepareException(var11, authentication); throw var11; &#125; catch (InternalAuthenticationServiceException var12) &#123; this.prepareException(var12, authentication); throw var12; &#125; catch (AuthenticationException var13) &#123; lastException = var13; &#125; &#125; &#125; if (result == null &amp;&amp; this.parent != null) &#123; try &#123; result = this.parent.authenticate(authentication); &#125; catch (ProviderNotFoundException var9) &#123; ; &#125; catch (AuthenticationException var10) &#123; lastException = var10; &#125; &#125; if (result != null) &#123; if (this.eraseCredentialsAfterAuthentication &amp;&amp; result instanceof CredentialsContainer) &#123; ((CredentialsContainer)result).eraseCredentials(); &#125; this.eventPublisher.publishAuthenticationSuccess(result); return result; &#125; else &#123; if (lastException == null) &#123; lastException = new ProviderNotFoundException(this.messages.getMessage(\"ProviderManager.providerNotFound\", new Object[]&#123;toTest.getName()&#125;, \"No AuthenticationProvider found for &#123;0&#125;\")); &#125; this.prepareException((AuthenticationException)lastException, authentication); throw lastException; &#125; &#125; 5、 具体的验证处理由DaoAuthenticationProvider的父类AbstractUserDetailsAuthenticationProvider的authenticate方法来完成，该方法先获取到登录的用户名，如果缓存中有UserDetails则从缓存中获取UserDetails如果没有则根据用户名和authentication获取UserDetails 后进行一系列验证成功后返回Authentication，具体代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.onlySupports\", \"Only UsernamePasswordAuthenticationToken is supported\")); String username = authentication.getPrincipal() == null ? \"NONE_PROVIDED\" : authentication.getName(); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); &#125; catch (UsernameNotFoundException var6) &#123; this.logger.debug(\"User '\" + username + \"' not found\"); if (this.hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; throw var6; &#125; Assert.notNull(user, \"retrieveUser returned null - a violation of the interface contract\"); &#125; try &#123; this.preAuthenticationChecks.check(user); this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); &#125; catch (AuthenticationException var7) &#123; if (!cacheWasUsed) &#123; throw var7; &#125; cacheWasUsed = false; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); this.preAuthenticationChecks.check(user); this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); &#125; this.postAuthenticationChecks.check(user); if (!cacheWasUsed) &#123; this.userCache.putUserInCache(user); &#125; Object principalToReturn = user; if (this.forcePrincipalAsString) &#123; principalToReturn = user.getUsername(); &#125; return this.createSuccessAuthentication(principalToReturn, authentication, user); &#125; 6、验证过程由DaoAuthenticationProvider的retrieveUser和additionalAuthenticationChecks方法来实现，具体代码如下12345678910111213141516171819protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; this.prepareTimingAttackProtection(); try &#123; UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); if (loadedUser == null) &#123; throw new InternalAuthenticationServiceException(\"UserDetailsService returned null, which is an interface contract violation\"); &#125; else &#123; return loadedUser; &#125; &#125; catch (UsernameNotFoundException var4) &#123; this.mitigateAgainstTimingAttack(authentication); throw var4; &#125; catch (InternalAuthenticationServiceException var5) &#123; throw var5; &#125; catch (Exception var6) &#123; throw new InternalAuthenticationServiceException(var6.getMessage(), var6); &#125; &#125; 123456789101112protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; if (authentication.getCredentials() == null) &#123; this.logger.debug(\"Authentication failed: no credentials provided\"); throw new BadCredentialsException(this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; else &#123; String presentedPassword = authentication.getCredentials().toString(); if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123; this.logger.debug(\"Authentication failed: password does not match stored value\"); throw new BadCredentialsException(this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; &#125; &#125; 这个方法通过loadUserByUsername来获取到数据库中的用户信息，所以我们要自己重写实现UserDetailsService接口的loadUserByUsername方法，实现如下12345678910111213141516171819202122232425262728293031@Servicepublic class UserDetailsServiceImpl implements UserDetailsService&#123; @Autowired private UserService userService; @Autowired private PermissionDao permissionDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; SysUser user = userService.getUser(username); if (user == null) &#123; throw new AuthenticationCredentialsNotFoundException(\"用户名不存在\"); &#125; else if (user.getStatus() == Status.LOCKED) &#123; throw new LockedException(\"用户被锁定，请联系管理员\"); &#125; else if (user.getStatus() == Status.DISABLED) &#123; throw new DisabledException(\"用户已被封禁\"); &#125; LoginUser loginUser = new LoginUser(); BeanUtils.copyProperties(user, loginUser); List&lt;Permission&gt; permissions = permissionDao.listByUserId(user.getId()); loginUser.setPermissions(permissions); return loginUser; &#125;&#125; 通过loadUserByUsername获取到数据库的用户信息在通过上面的两个方法和前端传过来的用户信息进行比对就完成了登录认证。 认证完成后成功失败等一系列处理在SecurityHandlerConfig进行处理，成功后将token储存到redis中。 可能说的不是很清楚，如果有搞不明白的小伙伴可以来找我一起讨论。最近一直在和老王研究微服务，等上线后我会写一些spring cloud相关的东西。","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/categories/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"DOM事件流 事件代理  JS作用域和作用域链","slug":"20180622-js原型链","date":"2018-06-22T14:00:44.000Z","updated":"2019-04-05T14:26:39.000Z","comments":true,"path":"2018/06/22/20180622-js原型链/","link":"","permalink":"http://yoursite.com/2018/06/22/20180622-js原型链/","excerpt":"内马尔进球了 我，里奥·谢特，现在慌得一批（我才不是梅西黑粉）这次我们来看下dom事件流，事件代理和js中的作用域作用域链。","text":"内马尔进球了 我，里奥·谢特，现在慌得一批（我才不是梅西黑粉）这次我们来看下dom事件流，事件代理和js中的作用域作用域链。 1.DOM事件流dom事件简单地说就是定义了一些JavaScript函数使他们能够响应页面元素发生的变化，如click事件。 事件的生命周期分为三个阶段 捕捉 目标 冒泡 a)捕捉阶段当某个事件被触发的时候，浏览器会找到涉及的元素，涉及的元素被称为目标，浏览器会先触发外层事件的处理器，最后才会轮到目标事件处理器。 b)目标阶段捕获阶段完成后，浏览器触发目标元素上任何已经添加的事件类型监听器。 c)冒泡阶段冒泡阶段与捕获阶段顺序正好相反，在这个阶段，浏览器会优先处理目标的事件处理器，然后一层层往外处理其余的事件处理器。 总结来说就是：冒泡事件按照最特定的事件目标到最不特定的事件目标的顺序触发。捕获事件是从最不特定的开始触发到最特定的事件。 看下这张图更助于理解 在JS中，绑定的事件默认的执行时间是在冒泡阶段执行，而非在捕获阶段，必须要理解 不过我们可以通过绑定事件时，指定事件执行时间是在冒泡阶段还是捕获阶段。 obj.addEventListener(event,function(){},bool) bool:false，代表冒泡阶段执行 bool:true，代表捕获阶段执行 JS在默认情况下获取事件后，就开始从根元素开始捕获所有该事件的监听对象，然后在冒泡阶段逐一执行。捕获阶段是在冒泡阶段前面 阻止冒泡 w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true； 阻止默认行为 w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false; ps:onclick,click,on()的优先关系：onclick&gt;click&gt;on()； onclick和click绑定的事件，彼此之间遵守事件冒泡规则，从内到外触发； on()绑定的事件，总是晚于onclick和click绑定的事件触发； 2.事件代理当我们需要对很多元素添加事件的时候，可以通过将事件添加到他的父节点而将事件委托给父节点来触发处理函数，这主要得益于浏览器的冒泡机制。123456789101112131415 &lt;ul id=\"parent-list\"&gt; &lt;li id=\"p1\"&gt;Item 1&lt;/li&gt; &lt;li id=\"p1\"&gt;Item 2&lt;/li&gt; &lt;li id=\"p1\"&gt;Item 3&lt;/li&gt; &lt;li id=\"p1\"&gt;Item 4&lt;/li&gt; &lt;/ul&gt; //下面实现事件代理 //获取父节点 为他添加一个click事件 document.getElementById(\"parent-list\").addEventListener(\"click\",function(e)&#123; //检查事件源e.target是否为li if(e.target &amp;&amp; e.target.nodeName.toUpperCase == \"LI\") //处理过程 console.log(\"List item\",e.target.id.replace(\"p\"),\"was clicked!\");&#125;); 为父节点添加一个click事件，当子节点被点击的时候，click事件会从子节点开始向上冒泡，通过判断e.target.nodeName来判断是否为我们需要处理的节点。并且通过e.target拿到了被点击的li节点。从而获取到相应的信息，并做处理。 我们可以用jQuery的delegate函数更为方便的处理1234$(\"#link-list\").delegate(\"a\",\"click\",function()&#123; //\"$(this)\"是被点击的节点 console.log(\"you clicked a link!\",$(this));&#125;); 3.JavaScript中的作用域和作用域链JavaScript函数的作用域：函数内的区域，就是这个函数的作用域，变量和函数在这个区域都可以访问操作。最外层函数外的区域叫全局作用域，函数内的区域叫局部作用域。 JavaScript变量的作用域：在源代码中变量所在的区域就是这个变量的作用域，变量在这个区域内可以被访问操作。在全局作用域上定义的变量叫全局变量，在函数内定义的变量叫局部变量（函数内声明但不加var 视为全局变量） 作用域链：作用域链（Scope Chain）是JavaScript内部的一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域，理解作用域链的作用原理。 执行环境：执行环境也被称为上下文，当解析器进入ECMAScript的可执行代码，解析器就进入一个执行环境，活动的执行环境组成一个逻辑上的栈，在这个逻辑栈顶部的执行环境就是当前运行的执行环境。 ps：ECMAScriptt中有三种可执行代码，Global、Function和Eval： eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript)字符串。看下面的例子： eval(“alert(‘专业做网站’)”)； 这行代码的作用等价于下面这行代码： alert(“专业做网站”); 全局环境即是Global可执行代码，函数即是Function可执行代码。逻辑栈是一种特殊的数据存储格式，特点是‘先进后出，后进先出’，添加数据会先压入逻辑栈顶部，删除数据必须先从顶部开始删除。 变量对象(Variable Object)、活动对象(Activation Object)和Arguments对象(Arguments Object) 每个执行环境都有一个与之关联的变量对象，当解析器进入执行环境时，就会创建一个变量对象，变量对象保存着在当前执行环境中声明的变量和函数的引用。 变量对象是一个抽象的概念，在不同的执行环境中，变量对象有不同的身份，在解析器进入任何执行环境之前，就已经创建了一个Global对象，当解析器进入全局执行环境时，Global对象就充当变量对象，当解析器进入一个函数时，就会创建一个活动对象充当变量对象。 解析器处理代码时的两个阶段:JavaScript解析器是一段一段解析处理代码的，解析器处理代码时的两个阶段：解析代码和执行代码。 当解析器进入执行环境时，变量对象就会添加执行环境中声明的变量和函数作为它的属性，这就意味着变量和函数在声明之前已经可用，变量值为undefined，这就是变量和函数声明提升(Hoisting)的原因，与此同时作用域链和this确定，此过程为解析阶段，俗称预解析。接着解析器开始执行代码，为变量添加相应值的引用，得到执行结果，此过程为执行阶段。 举个栗子12345var a=123;var b=\"abc\";function c()&#123; alert('11');&#125; 上述全局环境中的代码解析执行后，会将Global对象作为变量对象，保存以下数据。 12345678function testFn(a)&#123; var b=\"123\"; function c()&#123; alert(\"abc\"); &#125;&#125;testFn(10); 当解析器进入函数执行环境时，则会创建一个活动对象作为变量对象，活动对象还会创建一个Arguments对象，arguments对象是一个参数集合，用来保存参数，这就是我们写函数时可以使用arguments[0]等来使用参数的原因。 作用域链：每个执行环境都有一个与之关联的作用域链，当解析器进入执行环境时被定义，作用域链是一个对象列表，用来检索各个变量对象中的变量和函数，这样可以保证执行环境有权访问哪些变量和函数，举个栗子。12345678910111213var a='123';function testFn(b)&#123; var c='abc'; function testFn2()&#123; var d='efg'; alert(a); &#125; testFn2();&#125;testFn(10); testFn2内未声明变量a，为什么testFn2能调用全局变量a？整个过程是怎么发生的呢？请看下图。 当解析器进入全局执行环境时，调用变量和函数时只在Global对象中查找。 当解析器进入testFn函数执行环境时，函数内部属性[[scope]]中首先填入Global对象，然后将testFn活动对象添加到Global对象之前，形成一个作用域链当解析器进入testFn2函数执行环境时，函数内部属性[[scope]]首先填入父级的作用域链，然后再将当前的testFn2活动对象添加到作用域链的前端，形成一个新的作用域链。 testFn2调用变量a时，首先在当前的testFn2活动对象中查找，如果没有找到就顺着作用域链向上，在testFn活动对象中查找变量a，如果没有找到再顺着作用域链向上查找，直到在最后Global对象中找到为止，否则报错。所以函数内部可以调用外部环境的变量，外部环境不能调用函数内部的变量，这就是作用域特性的原理。 参考文献：作者未知\u0000\u0000\b","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Javascript闭包初步了解","slug":"20180622-js闭包","date":"2018-06-22T09:47:44.000Z","updated":"2019-04-05T14:26:43.000Z","comments":true,"path":"2018/06/22/20180622-js闭包/","link":"","permalink":"http://yoursite.com/2018/06/22/20180622-js闭包/","excerpt":"没错，在下就是这么勤劳 ，这里来总结一下js闭包，搬运自阮大佬的日志","text":"没错，在下就是这么勤劳 ，这里来总结一下js闭包，搬运自阮大佬的日志 闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。1.变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 1234567var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 12345 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！1234567 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 2.如何从外部读取局部变量出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789101112131415function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 3.闭包的概念上面代码中的f2函数，就是闭包。 各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我(阮大佬)的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 4.闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。123456789101112131415161718192021 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 5.使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 常见陷阱12345678910111213function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; console.log(funcs[i]());&#125; 乍一看，以为输出 0~9 ，万万没想到输出10个10？ 这里的陷阱就是：函数带()才是执行函数， 单纯的一句 var f = function() { alert(‘Hi’); }; 是不会弹窗的，后面接一句 f(); 才会执行函数内部的代码。上面代码翻译一下就是：12345678910111213var result = new Array(), i;result[0] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！result[1] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！...result[9] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！i = 10;funcs = result;result = null;console.log(i); // funcs[0]()就是执行 return i 语句，就是返回10console.log(i); // funcs[1]()就是执行 return i 语句，就是返回10...console.log(i); // funcs[9]()就是执行 return i 语句，就是返回10 为什么只垃圾回收了 result，但却不收了 i 呢？ 因为 i 还在被 function 引用着啊。好比一个餐厅，盘子总是有限的，所以服务员会去巡台回收空盘子，但还装着菜的盘子他怎么敢收？ 当然，你自己手动倒掉了盘子里面的菜（=null），那盘子就会被收走了，这就是所谓的内存回收机制。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"前端跨域问题的解决方案","slug":"20180623-前端跨域问题的解决方法","date":"2018-06-22T07:47:44.000Z","updated":"2019-04-05T14:26:51.000Z","comments":true,"path":"2018/06/22/20180623-前端跨域问题的解决方法/","link":"","permalink":"http://yoursite.com/2018/06/22/20180623-前端跨域问题的解决方法/","excerpt":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧","text":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧 1.什么是跨域 域名 说明 是否跨域 http://www.a.com/a.js http://www.a.com/b.js 同一域名 否 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名文件夹不同 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名端口不同 是 http://www.a.com/a.js https://www.a.com/b.js 同一域名协议不同 是 http://www.a.com/a.js http://70.32.92.74/b.js 对应ip相同 是 http://www.a.com/a.js http://script.a.com/b.js 子域名不同 是 http://www.bilibili.com/a.js http://www.a.com/b.js 不同域名 是 2.解决方法1.JSONP实现跨域JSONP是json with padding（填充式json或参数式json）的简称 JSONP包含两部分：回调函数和数据。 JSONP实现跨域请求的原理是动态创建&lt;script&gt;标签，然后利用&lt;script&gt;的src 不受同源策略约束来跨域获取数据1234567function handleResponse(response)&#123; console.log(response.data);&#125;var script = document.createElement('script');script.src = 'http:/www.domain.com/json?callback=handleResponse';document.body.insertBefore(script, document.body.firstChild);//handleResonse(&#123;\"data\": \"zhe\"&#125;) 具体流程：通过script标签请求时后台根据相应的参数(json,handleResponse)来生成相应的json数据(handleResponse({&quot;data&quot;: &quot;zhe&quot;}))，最后这个返回的json数据就会被放在当前js文件中被执行。 JSONP的缺陷：1、请求代码存在安全隐患。借助JSONP有可能进行跨站请求伪造(CSRF)攻击。2、无法确定jsonp成功与否3、只能实现get请求1234567$.ajax(&#123; url: 'http://www.domain.com/json', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;); 2.document.domain + iframe实现跨域这个方案只适用于主域名相同，子域名不同的跨域处理。 原理是通过js强制设置document.domain 为基础主域。 123456789101112//父窗口www.domain.com/a.html&lt;iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt;//子窗口child.domain.com/b.html&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 3.location.hash+iframe实现跨域原理是利用location.hash来进行传值。 假设域名a.com下的文件cs1.html要和domain.com域名下的cs2.html传递信息。1) cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向domain.com域名下的cs2.html页面2) cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据3) 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //先是a.com下的文件cs1.html文件：function startRequest()&#123; var ifr = document.createElement('iframe'); ifr.style.display = 'none'; ifr.src = 'http://www.domain.com/lab/cscript/cs2.html#paramdo'; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : ''; if (console.log) &#123; console.log('Now the data is '+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000);//cnblogs.com域名下的cs2.html://模拟一个简单的参数处理操作switch(location.hash)&#123; case '#paramdo': callBack(); break; case '#paramset': //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = 'somedata'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = 'http://a.com/test/cscript/cs3.html#somedata'; // 注意该文件在\"a.com\"域下 document.body.appendChild(ifrproxy); &#125;&#125;//a.com下的域名cs3.html//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 4. window.name + iframe实现跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 原理是通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//1.）a.html：(www.domain1.com/a.html)var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data);&#125;);//2.）proxy.html：(www.domain1.com/proxy....//中间代理页，与a.html同域，内容为空即可。//3.）b.html：(www.domain2.com/b.html)&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 5.postMessage实现跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 12345678910111213141516171819202122232425262728293031323334//1.）a.html：(www.domain1.com/a.html)&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt;//2.）b.html：(www.domain2.com/b.html)&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; 6.CORS（跨域资源共享）实现跨域CORS是通过一系列特殊的HTTP头来解决这一问题，这些http头信息可以允许双方判断请求成功或者失败 在发送跨域HTTP请求时，支持CORS的浏览器会引入额外的Origin头信息来指定请求的源。这个头信息需要包含三个部分——协议、域名和端口 服务端的工作是检查头信息是否接受该请求。如果请求被接受，那么需要返回一个包含Access-Control-Allow-Origin，其值与客户端Origin值相同的响应头 如果资源是公共的允许任何源发送请求，服务器可以返回一个通配符Access-Control-Allow-Origin: *如果匹配成功，那么浏览器将会继续处理这个请求，否则禁止该请求。123456789101112131415161718192021222324252627282930//1.）原生ajax// 前端设置是否带cookiexhr.withCredentials = true;示例代码：var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;;//2.）jQuery ajax$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); java中后台可以这样设置12345 //导入包：import javax.servlet.http.HttpServletResponse; //接口参数中定义：HttpServletResponse responseresponse.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\"); // 若有端口需写全（协议+域名+端口）response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); 7.Nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 配置信息：123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 前端代码12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); node.js后台 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 8.Web Sockets实现跨域web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。 12345var socket = new WebSockt('ws://www.domain.com');//http-&gt;ws; https-&gt;wsssocket.send('hello WebSockt');socket.onmessage = function(event)&#123; var data = event.data;&#125; 参考资料阮一峰大佬的CORS 详解","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"web性能优化","slug":"Web性能优化","date":"2018-06-21T15:47:44.000Z","updated":"2019-04-05T14:28:41.000Z","comments":true,"path":"2018/06/21/Web性能优化/","link":"","permalink":"http://yoursite.com/2018/06/21/Web性能优化/","excerpt":"Web性能优化","text":"Web性能优化 1、 减少http请求a) 在浏览器和服务器发生通信的时候 就已经消耗了大量的时间b) 网速相同的条件下 下载一个100kb的图片比下载两个50kb的图片要快c) 减少http请求的主要手段是合并css 合并JavaScript 合并图片 2、 使用浏览器缓存a) 一个网站中 css js logo 图标这些静态资源文件更新的频率都比较低 如果将这些文件缓存在浏览器中可以极好地改善型性能b) 通过设置http头中的cache-control和expires属性 可以设定浏览器缓存c) 在某些时候 静态资源文件变化需要及时应用到客户端浏览器 这种情况 可以通过改变文件名称实现 即更新js文件不是更新js文件内容d) 使用浏览器缓存策略的网站在更新静态资源时 应采用分批次更新的方法 比如需要更新10个图标文件 不宜把10个文件一次全部更新 应该一个文件一个文件逐步更新 并有一定的间隔时间 以免浏览器突然大量缓存失效 3、 服务端启用压缩4、 css放在页面最上面 js放在页面最下面a) 浏览器会在下载完全部css之后才对整个页面进行渲染 因此最好的做法是将css放在页面最上面 让浏览器尽快下载cssb) Js则相反 浏览器在加载js后立即执行 有可能会阻塞整个页面 造成页面显示缓慢 因此js最好放在页面最下面 但如果解析页面的时候就需要用到js 这里就不适合放在底部了 5、 精简css和js文件a) css和js压缩 减少下载的文件体积 常用的方式是使用 yui compressor 它的特点是：移除注释 移除额外的空格 细微的优化 标识符替换b) 压缩js java -jar yuicompressor-2.4.2.jar api.js&gt;api.min.js 压缩css java -jar yuicompressor-2.4.2.jar style.css&gt;style.min.css 6、 减少对dom的操作a) 对dom操作的代价是高昂的b) 修改和访问dom元素会造成页面的重绘和重排 造成重绘重排的原因i. 修改domii. 修改样式表iii. 用户事件c) 网页生成的过程大致可以分为五个步骤i. html转换成domii. css代码转换成cssomiii. 结合dom和cssom 生成一棵渲染树iv. 生成布局 即将所有渲染树的所有节点进行平面合成v. 将布局绘制在屏幕上 7、 使用json格式进行数据交换8、 减少cookie传输a) 因为cookie是本地的磁盘文件 每次浏览器都会去读取相应的cookie所以建议去除不必要的cookie 使cookie体积尽量小 9、 使用cdn加速a) cdn全称是content delivery network 即内容分发网络b) cdn本质仍然是一个缓存 而且将数据缓存在离用户最近的地方 使用户最快的获取数据c) cdn能够缓存的一般般是静态资源 如图片 文件 css script脚本 静态网页d) 实时性不好使cdn的缺陷 10、web服务器配置gzip压缩#####什么是gzip压缩? HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来.一般对纯文本内容可压缩到原大小的40%.这样传输就快了，效果就是你点击网址后会很快的显示出来.当然这也会增加服务器的负载. 一般服务器中都安装有这个功能模块的。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"ES6这些就够了","slug":"20180625-ES6","date":"2018-06-21T15:47:44.000Z","updated":"2019-04-05T14:27:04.000Z","comments":true,"path":"2018/06/21/20180625-ES6/","link":"","permalink":"http://yoursite.com/2018/06/21/20180625-ES6/","excerpt":"本来想自己写点ES6的东西但是查相关的资料的时候找到了不错的，这里就搬运一下吧。原文地址：简书作者 陈嘻嘻啊：ES6这些就够了 PS：ECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言","text":"本来想自己写点ES6的东西但是查相关的资料的时候找到了不错的，这里就搬运一下吧。原文地址：简书作者 陈嘻嘻啊：ES6这些就够了 PS：ECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言 刚开始用vue或者react，很多时候我们都会把ES6这个大兄弟加入我们的技术栈中。但是ES6那么多那么多特性，我们真的需要全部都掌握吗？秉着二八原则，掌握好常用的、有用的这个可以让我们的开发快速起飞。 接下来我们就聊聊ES6那些可爱的新特性吧。1.变量声明const和let在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如: 1234567function aa() &#123; if(bool) &#123; var test = 'hello man' &#125; else &#123; console.log(test) &#125;&#125; 以上的代码实际上是：12345678910function aa() &#123; var test // 变量提升 if(bool) &#123; test = 'hello man' &#125; else &#123; //此处访问test 值为undefined console.log(test) &#125; //此处访问test 值为undefined &#125; 以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。 接下来ES6主角登场：我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？ 在一个函数内部 在一个代码块内部 说白了 {}大括号内的代码块即为let 和 const的作用域。 看以下代码：12345678function aa() &#123; if(bool) &#123; let test = 'hello man' &#125; else &#123; //test 在此处访问不到 console.log(test) &#125;&#125; let的作用域是在它所在当前代码块，但不会被提升到当前函数的最顶部。 再来说说constconst 声明的变量都会被认为是常量，意思就是它的值被设置完成后就不能再修改了。12const name = 'lux'name = 'joe' //再次赋值此时会报错 还有，如果const的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址没有变就行。12345const student = &#123; name: 'cc' &#125;// 没毛病student.name = 'yy'// 如果这样子就会报错了student = &#123; name: 'yy' &#125; 说一道面试题1234567var funcs = [] for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;) &#125; funcs.forEach(function(func) &#123; func() &#125;) 这样的面试题是大家常见，很多同学一看就知道输出 10 十次但是如果我们想依次输出0到9呢？有两种解决方法。直接看一下代码。1234567891011121314// ES5告诉我们可以利用闭包解决这个问题 var funcs = [] for (var i = 0; i &lt; 10; i++) &#123; funcs.push( (function(value) &#123; return function() &#123; console.log(value) &#125; &#125;)(i) ) &#125; funcs.forEach(function(func) &#123; func() &#125;) 12345678// 再来看看es6怎么处理的 const funcs = [] for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;) &#125; funcs.forEach(func =&gt; func()) 达到相同的效果，es6简洁的解决方案是不是更让你心动！！！ 2.模板字符串ES6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。 第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。123456//ES5 var name = 'lux' console.log('hello' + name) //es6 const name = 'lux' console.log(`hello $&#123;name&#125;`) //hello lux 第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号()直接搞定。12345678// ES5 var msg = \"Hi \\ man! \" // ES6 const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt;` 对于字符串ES6当然也提供了很多厉害也很有意思的方法😊 说几个常用的。1234567891011121314// 1.includes：判断是否包含然后直接返回布尔值 const str = 'hahay' console.log(str.includes('y')) // true // 2.repeat: 获取字符串重复n次 const str = 'he' console.log(str.repeat(3)) // 'hehehe' //如果你带入小数, Math.floor(num) 来处理 // s.repeat(3.1) 或者 s.repeat(3.9) 都当做成 s.repeat(3) 来处理 // 3. startsWith 和 endsWith 判断是否以 给定文本 开始或者结束 const str = 'hello world!' console.log(str.startsWith('hello')) // true console.log(str.endsWith('!')) // true 3.函数函数默认参数在ES5我们给函数定义参数默认值是怎么样？123456function action(num) &#123; num = num || 200 //当传入num时，num为传入的值 //当没传入参数时，num即有了默认值200 return num &#125; 但细心观察的同学们肯定会发现，num传入为0的时候就是false，但是我们实际的需求就是要拿到num = 0，此时num = 200 明显与我们的实际想要的效果明显不一样 ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。123456function action(num = 200) &#123; console.log(num) &#125; action(0) // 0 action() //200 action(300) //300 箭头函数ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。 箭头函数最直观的三个特点。 不需要 function 关键字来创建函数 省略 return 关键字 继承当前上下文的 this 关键字1234567//例如： [1,2,3].map(x =&gt; x + 1)//等同于： [1,2,3].map((function(x)&#123; return x + 1 &#125;).bind(this)) 这里我插一段call，apply，bind的介绍吧 js在开发的过程中经常会用到this，来表示当前运行环境本身，通过this来取得当前环境下的各种数据和方法。但是，有时候我们想要让a对象借b对象的方法用一下，要怎么办呢？例如：12345678910111213141516var person = &#123; name: '鲸某人', sayName: function()&#123; console.log(this.name) &#125;&#125;var person1 = &#123; name: '高某人'&#125;//如果我们想让鲸某人叫一下高某人，咋办呢？//只要call他一下就可以啦person.sayName.call(person1)//同样的，使用apply和bind也可以达到相同的效果：person.sayName.apply(person1)//下边会说，为什么bind后边多了个()person.sayName.bind(person1)() apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 。。继续说箭头函数当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return；例如:12var people = name =&gt; 'hello' + name //参数name就没有括号 作为参考12345var people = (name, age) =&gt; &#123; const fullName = 'hello' + name return fullName&#125;//如果缺少()或者&#123;&#125;就会报错 要不整一道笔试题？哈哈哈哈哈哈哈哈。我不管我先上代码了1234567891011121314// 请使用ES6重构以下代码 var calculate = function(x, y, z) &#123; if (typeof x != 'number') &#123; x = 0 &#125; if (typeof y != 'number') &#123; y = 6 &#125; var dwt = x % y var result if (dwt == z) &#123; result = true &#125; if (dwt != z) &#123; result = false &#125; return result &#125; 123456const calculate = (x, y, z) =&gt; &#123; x = typeof x !== 'number' ? 0 : x y = typeof y !== 'number' ? 6 : y return x % y === z &#125; 4.拓展的对象功能对象初始化简写 ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如：123456function people(name, age) &#123; return &#123; name: name, age: age &#125;; &#125; 键值对重名，ES6可以简写如下：123456function people(name, age) &#123; return &#123; name, age &#125;; &#125; ES6 同样改进了为对象字面量方法赋值的语法。ES5为对象添加方法：123456const people = &#123; name: 'lux', getName: function() &#123; console.log(this.name) &#125; &#125; ES6通过省略冒号与 function 关键字，将这个语法变得更简洁123456const people = &#123; name: 'lux', getName () &#123; console.log(this.name) &#125; &#125; ES6 对象提供了 Object.assign()这个方法来实现浅复制。Object.assign() 可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}1234567891011121314const objA = &#123; name: 'cc', age: 18 &#125; const objB = &#123; address: 'beijing' &#125; const objC = &#123;&#125; // 这个为目标对象 const obj = Object.assign(objC, objA, objB) // 我们将 objA objB objC obj 分别输出看看 console.log(objA) // &#123; name: 'cc', age: 18 &#125; console.log(objB) // &#123; address: 'beijing' &#125; console.log(objC) // &#123; name: 'cc', age: 18, address: 'beijing' &#125; console.log(obj) // &#123; name: 'cc', age: 18, address: 'beijing' &#125; // 是的，目标对象ObjC的值被改变了。 // so，如果objC也是你的一个源对象的话。请在objC前面填在一个目标对象&#123;&#125; Object.assign(&#123;&#125;, objC, objA, objB) 5.更方便的数据访问–解构数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程 ES5我们提取对象中的信息形式如下：1234567const people = &#123; name: 'lux', age: 20 &#125; const name = people.name const age = people.age console.log(name + ' --- ' + age) 是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，解构能让我们从对象或者数组里取出数据存为变量，例如123456789101112//对象 const people = &#123; name: 'lux', age: 20 &#125; const &#123; name, age &#125; = people console.log(`$&#123;name&#125; --- $&#123;age&#125;`) //数组 const color = ['red', 'blue'] const [first, second] = color console.log(first) //'red' console.log(second) //'blue' 要不来点儿面试题，看看自己的掌握情况？123456789// 请使用 ES6 重构一下代码 // 第一题 var jsonParse = require('body-parser').jsonParse // 第二题 var body = request.body var username = body.username var password = body.password 1234// 1. import &#123; jsonParse &#125; from 'body-parser' // 2. const &#123; body, body: &#123; username, password &#125; &#125; = request 6.Spread Operator 展开运算符ES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。 组装对象或者数组12345678910//数组 const color = ['red', 'yellow'] const colorful = [...color, 'green', 'pink'] console.log(colorful) //[red, yellow, green, pink] //对象 const alp = &#123; fist: 'a', second: 'b'&#125; const alphabets = &#123; ...alp, third: 'c' &#125; console.log(alphabets) //&#123; \"fist\": \"a\", \"second\": \"b\", \"third\": \"c\"&#125; 有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项1234567891011121314//数组 const number = [1,2,3,4,5] const [first, ...rest] = number console.log(rest) //2,3,4,5 //对象 const user = &#123; username: 'lux', gender: 'female', age: 19, address: 'peking' &#125; const &#123; username, ...rest &#125; = user console.log(rest) //&#123;\"address\": \"peking\", \"age\": 19, \"gender\": \"female\"&#125; 对于 Object 而言，还可以用于组合成新的 Object 。(ES2017 stage-2 proposal) 当然如果有重复的属性名，右边覆盖左边1234567891011const first = &#123; a: 1, b: 2, c: 6, &#125; const second = &#123; c: 3, d: 4 &#125; const total = &#123; ...first, ...second &#125; console.log(total) // &#123; a: 1, b: 2, c: 3, d: 4 &#125; 7.import 和 exportimport导入模块、export导出模块123456789101112131415161718//全部导入import people from './example'//有一种特殊情况，即允许你将整个模块当作单一对象进行导入//该模块的所有导出都会作为对象的属性存在import * as example from \"./example.js\"console.log(example.name)console.log(example.age)console.log(example.getName())//导入部分import &#123;name, age&#125; from './example'// 导出默认, 有且只有一个默认export default App// 部分导出export class App extend Component &#123;&#125;; 导入的时候有没有大括号的区别是什么1234567891.当用export default people导出时，就用 import people 导入（不带大括号）2.一个文件里，有且只能有一个export default。但可以有多个export。3.当用export name 时，就用import &#123; name &#125;导入（记得带上大括号）4.当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, &#123; name, age &#125;5.当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example 8. Promise 在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。 说白了就是用同步的方式去写异步代码。 发起异步请求1234fetch('/api/todos') .then(res =&gt; res.json()) .then(data =&gt; (&#123; data &#125;)) .catch(err =&gt; (&#123; err &#125;)); 详细的用法可以参考这几篇文章 Promise使用详解1 Promise使用详解2 Promise使用详解3 9.Generators生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。 这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。 OK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。 12345678910111213// 生成器 function *createIterator() &#123; yield 1; yield 2; yield 3; &#125; // 生成器能像正规函数那样被调用，但会返回一个迭代器 let iterator = createIterator(); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 那生成器和迭代器又有什么用处呢？ 围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。 生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。 那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的12345678910111213141516171819202122function run(taskDef) &#123; //taskDef即一个生成器函数 // 创建迭代器，让它在别处可用 let task = taskDef(); // 启动任务 let result = task.next(); // 递归使用函数来保持对 next() 的调用 function step() &#123; // 如果还有更多要做的 if (!result.done) &#123; result = task.next(); step(); &#125; &#125; // 开始处理过程 step(); &#125; 生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。你不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 yield 来等待异步操作结束。 ES6新特性远不止于此，但对于我们日常的开发来说。这算不上全部，但是能算得上是高频使用了。当然还有很有好玩有意思的特性。比如一些数组的新方法、class…等等。包括用set处理数组去重问题等等。最后感谢大佬的归纳总结。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"linux中常见的指令","slug":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？","date":"2018-06-21T12:47:44.000Z","updated":"2019-04-05T09:12:46.000Z","comments":true,"path":"2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","link":"","permalink":"http://yoursite.com/2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","excerpt":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？","text":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？ 查看当前进程：ps 查看负载情况：free 查看内存的使用情况 top 动态显示cpu的负载情况 执行退出：exit 查看当前路径：pwd 2.如何清屏？怎么退出当前命令？怎么执行s会面？ 清屏：clear 退出当前：ctrl+c 执行睡眠：ctrl+z fg恢复后台 3.ls命令执行什么功能？可以带哪些参数？ ls执行的功能：列出指定目录中的目录，以及文件 有哪些参数：a所有文件 l详细信息，包括大小写字节数，可读可写，可执行的权限等 4.目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？创建目录：mkdir创建文件：典型的如touch vi复制文件：cp 5.查看文件内容的命令有哪些？vi 文件名 编辑方式查看，可以修改cat 文件名 显示全部文件内容more 文件名 分页显示文件内容less 文件名 与more相似 可以往前翻页tail 文件名 仅查看尾部 可以指定行数head 文件名 仅查看头部 可以指定行数 6.移动文件 改名 用哪个命令？mv改名 将文件test改为new mv test new1 mv将目录 /usr/men中的所有文件移到当前目录 mv /usr/men/*. 7.复制 删除文件复制 cp [-adfilprsu] 源文件(source) 目标文件(destination) 删除 rm [fir] 文件或目录 8.常用的通配符和含义“？”可替代单个字符。 ·“*”可替代任意多个字符。 ·方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC] 15. 用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)wc 命令 - c 统计字节数。 – l 统计行数。 - w 统计字数。 9.终止进程kill -9 pid 10.查找自己所在终端的信息who am i","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]}]}