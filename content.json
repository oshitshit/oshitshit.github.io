{"meta":{"title":"哦谢特谢特","subtitle":"苟利国家生死以","description":null,"author":"哦谢特谢特","url":"http://yoursite.com"},"pages":[{"title":"Linux","date":"2018-06-21T07:46:09.000Z","updated":"2018-06-21T07:46:09.000Z","comments":true,"path":"Linux/index.html","permalink":"http://yoursite.com/Linux/index.html","excerpt":"","text":""}],"posts":[{"title":"Javascript闭包初步了解","slug":"20180622-js闭包","date":"2018-06-22T09:47:44.000Z","updated":"2018-06-22T10:30:57.000Z","comments":true,"path":"2018/06/22/20180622-js闭包/","link":"","permalink":"http://yoursite.com/2018/06/22/20180622-js闭包/","excerpt":"没错，在下就是这么勤劳 ，这里来总结一下js闭包，搬运自阮大佬的日志 闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。1.变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。","text":"没错，在下就是这么勤劳 ，这里来总结一下js闭包，搬运自阮大佬的日志 闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。1.变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 1234567var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 12345 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！1234567 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 2.如何从外部读取局部变量出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789101112131415function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 3.闭包的概念上面代码中的f2函数，就是闭包。 各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我(阮大佬)的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 4.闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。123456789101112131415161718192021 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 5.使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 常见陷阱12345678910111213function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; console.log(funcs[i]());&#125; 乍一看，以为输出 0~9 ，万万没想到输出10个10？ 这里的陷阱就是：函数带()才是执行函数， 单纯的一句 var f = function() { alert(‘Hi’); }; 是不会弹窗的，后面接一句 f(); 才会执行函数内部的代码。上面代码翻译一下就是：12345678910111213var result = new Array(), i;result[0] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！result[1] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！...result[9] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！i = 10;funcs = result;result = null;console.log(i); // funcs[0]()就是执行 return i 语句，就是返回10console.log(i); // funcs[1]()就是执行 return i 语句，就是返回10...console.log(i); // funcs[9]()就是执行 return i 语句，就是返回10 为什么只垃圾回收了 result，但却不收了 i 呢？ 因为 i 还在被 function 引用着啊。好比一个餐厅，盘子总是有限的，所以服务员会去巡台回收空盘子，但还装着菜的盘子他怎么敢收？ 当然，你自己手动倒掉了盘子里面的菜（=null），那盘子就会被收走了，这就是所谓的内存回收机制。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"前端跨域问题的解决方案","slug":"前端跨域问题的解决方法","date":"2018-06-22T07:47:44.000Z","updated":"2018-06-22T10:28:14.000Z","comments":true,"path":"2018/06/22/前端跨域问题的解决方法/","link":"","permalink":"http://yoursite.com/2018/06/22/前端跨域问题的解决方法/","excerpt":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧 1.什么是跨域 域名 说明 是否跨域 http://www.a.com/a.js http://www.a.com/b.js 同一域名 否 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名文件夹不同 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名端口不同 是 http://www.a.com/a.js https://www.a.com/b.js 同一域名协议不同 是 http://www.a.com/a.js http://70.32.92.74/b.js 对应ip相同 是 http://www.a.com/a.js http://script.a.com/b.js 子域名不同 是 http://www.bilibili.com/a.js http://www.a.com/b.js 不同域名 是 2.解决方法1.JSONP实现跨域JSONP是json with padding（填充式json或参数式json）的简称","text":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧 1.什么是跨域 域名 说明 是否跨域 http://www.a.com/a.js http://www.a.com/b.js 同一域名 否 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名文件夹不同 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名端口不同 是 http://www.a.com/a.js https://www.a.com/b.js 同一域名协议不同 是 http://www.a.com/a.js http://70.32.92.74/b.js 对应ip相同 是 http://www.a.com/a.js http://script.a.com/b.js 子域名不同 是 http://www.bilibili.com/a.js http://www.a.com/b.js 不同域名 是 2.解决方法1.JSONP实现跨域JSONP是json with padding（填充式json或参数式json）的简称JSONP包含两部分：回调函数和数据。 JSONP实现跨域请求的原理是动态创建&lt;script&gt;标签，然后利用&lt;script&gt;的src 不受同源策略约束来跨域获取数据1234567function handleResponse(response)&#123; console.log(response.data);&#125;var script = document.createElement('script');script.src = 'http:/www.domain.com/json?callback=handleResponse';document.body.insertBefore(script, document.body.firstChild);//handleResonse(&#123;\"data\": \"zhe\"&#125;) 具体流程：通过script标签请求时后台根据相应的参数(json,handleResponse)来生成相应的json数据(handleResponse({&quot;data&quot;: &quot;zhe&quot;}))，最后这个返回的json数据就会被放在当前js文件中被执行。 JSONP的缺陷：1、请求代码存在安全隐患。借助JSONP有可能进行跨站请求伪造(CSRF)攻击。2、无法确定jsonp成功与否3、只能实现get请求1234567$.ajax(&#123; url: 'http://www.domain.com/json', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;); 2.document.domain + iframe实现跨域这个方案只适用于主域名相同，子域名不同的跨域处理。 原理是通过js强制设置document.domain 为基础主域。 123456789101112//父窗口www.domain.com/a.html&lt;iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt;//子窗口child.domain.com/b.html&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 3.location.hash+iframe实现跨域原理是利用location.hash来进行传值。 假设域名a.com下的文件cs1.html要和domain.com域名下的cs2.html传递信息。1) cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向domain.com域名下的cs2.html页面2) cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据3) 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //先是a.com下的文件cs1.html文件：function startRequest()&#123; var ifr = document.createElement('iframe'); ifr.style.display = 'none'; ifr.src = 'http://www.domain.com/lab/cscript/cs2.html#paramdo'; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : ''; if (console.log) &#123; console.log('Now the data is '+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000);//cnblogs.com域名下的cs2.html://模拟一个简单的参数处理操作switch(location.hash)&#123; case '#paramdo': callBack(); break; case '#paramset': //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = 'somedata'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = 'http://a.com/test/cscript/cs3.html#somedata'; // 注意该文件在\"a.com\"域下 document.body.appendChild(ifrproxy); &#125;&#125;//a.com下的域名cs3.html//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 4. window.name + iframe实现跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 原理是通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//1.）a.html：(www.domain1.com/a.html)var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data);&#125;);//2.）proxy.html：(www.domain1.com/proxy....//中间代理页，与a.html同域，内容为空即可。//3.）b.html：(www.domain2.com/b.html)&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 5.postMessage实现跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 12345678910111213141516171819202122232425262728293031323334//1.）a.html：(www.domain1.com/a.html)&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt;//2.）b.html：(www.domain2.com/b.html)&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; 6.CORS（跨域资源共享）实现跨域CORS是通过一系列特殊的HTTP头来解决这一问题，这些http头信息可以允许双方判断请求成功或者失败 在发送跨域HTTP请求时，支持CORS的浏览器会引入额外的Origin头信息来指定请求的源。这个头信息需要包含三个部分——协议、域名和端口 服务端的工作是检查头信息是否接受该请求。如果请求被接受，那么需要返回一个包含Access-Control-Allow-Origin，其值与客户端Origin值相同的响应头 如果资源是公共的允许任何源发送请求，服务器可以返回一个通配符Access-Control-Allow-Origin: *如果匹配成功，那么浏览器将会继续处理这个请求，否则禁止该请求。123456789101112131415161718192021222324252627282930//1.）原生ajax// 前端设置是否带cookiexhr.withCredentials = true;示例代码：var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;;//2.）jQuery ajax$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); java中后台可以这样设置12345 //导入包：import javax.servlet.http.HttpServletResponse; //接口参数中定义：HttpServletResponse responseresponse.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\"); // 若有端口需写全（协议+域名+端口）response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); 7.Nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 配置信息：123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 前端代码12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); node.js后台 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 8.Web Sockets实现跨域web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。 12345var socket = new WebSockt('ws://www.domain.com');//http-&gt;ws; https-&gt;wsssocket.send('hello WebSockt');socket.onmessage = function(event)&#123; var data = event.data;&#125; 参考资料阮一峰大佬的CORS 详解","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"web性能优化","slug":"Web性能优化","date":"2018-06-21T15:47:44.000Z","updated":"2018-06-22T10:30:38.000Z","comments":true,"path":"2018/06/21/Web性能优化/","link":"","permalink":"http://yoursite.com/2018/06/21/Web性能优化/","excerpt":"Web性能优化1、 减少http请求a) 在浏览器和服务器发生通信的时候 就已经消耗了大量的时间b) 网速相同的条件下 下载一个100kb的图片比下载两个50kb的图片要快c) 减少http请求的主要手段是合并css 合并JavaScript 合并图片","text":"Web性能优化1、 减少http请求a) 在浏览器和服务器发生通信的时候 就已经消耗了大量的时间b) 网速相同的条件下 下载一个100kb的图片比下载两个50kb的图片要快c) 减少http请求的主要手段是合并css 合并JavaScript 合并图片 2、 使用浏览器缓存a) 一个网站中 css js logo 图标这些静态资源文件更新的频率都比较低 如果将这些文件缓存在浏览器中可以极好地改善型性能b) 通过设置http头中的cache-control和expires属性 可以设定浏览器缓存c) 在某些时候 静态资源文件变化需要及时应用到客户端浏览器 这种情况 可以通过改变文件名称实现 即更新js文件不是更新js文件内容d) 使用留恋其缓存策略的网站在更新静态资源时 应采用分批次更新的方法 比如需要更新10个图标文件 不宜把10个文件一次全部更新 应该一个文件一个文件逐步更新 并有一定的间隔时间 以免浏览器突然大量缓存失效 3、 服务端启用压缩4、 css放在页面最上面 js放在页面最下面a) 浏览器会在下载完全部css之后才对整个页面进行渲染 因此最好的做法是将css放在页面最上面 让浏览器尽快下载cssb) Js则相反 浏览器在加载js后立即执行 有可能会阻塞整个页面 造成页面显示缓慢 因此js最好放在页面最下面 但如果解析页面的时候就需要用到js 这里就不适合放在底部了 5、 精简css和js文件a) css和js压缩 减少下载的文件体积 常用的方式是使用 yui compressor 它的特点是：移除注释 移除额外的空格 细微的优化 标识符替换b) 压缩js java -jar yuicompressor-2.4.2.jar api.js&gt;api.min.js 压缩css java -jar yuicompressor-2.4.2.jar style.css&gt;style.min.css 6、 减少对dom的操作a) 对dom操作的代价是高昂的b) 修改和访问dom元素会造成页面的重绘和重排 造成重绘重排的原因i. 修改domii. 修改样式表iii. 用户事件c) 网页生成的过程大致可以分为五个步骤i. html转换成domii. css代码转换成cssomiii. 结合dom和cssom 生成一棵渲染树iv. 生成布局 即将所有渲染树的所有节点进行平面合成v. 将布局绘制在屏幕上 7、 使用json格式进行数据交换8、 减少cookie传输a) 因为cookie是本地的磁盘文件 每次浏览器都会去读取相应的cookie所以建议去除不必要的cookie 使cookie体积尽量小 9、 使用cdn加速a) cdn全称是content delivery network 即内容分发网络b) cdn本质仍然是一个缓存 而且将数据缓存在离用户最近的地方 使用户最快的获取数据c) cdn能够缓存的一般般是静态资源 如图片 文件 css script脚本 静态网页d) 实时性不好使cdn的缺陷","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"linux中常见的指令","slug":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？","date":"2018-06-21T12:47:44.000Z","updated":"2018-06-21T14:31:14.000Z","comments":true,"path":"2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","link":"","permalink":"http://yoursite.com/2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","excerpt":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？ 查看当前进程：ps 查看负载情况：free 查看内存的使用情况 top 动态显示cpu的负载情况 执行退出：exit 查看当前路径：pwd","text":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？ 查看当前进程：ps 查看负载情况：free 查看内存的使用情况 top 动态显示cpu的负载情况 执行退出：exit 查看当前路径：pwd 2.如何清屏？怎么退出当前命令？怎么执行s会面？ 清屏：clear 退出当前：ctrl+c 执行睡眠：ctrl+z fg恢复后台 3.ls命令执行什么功能？可以带哪些参数？ ls执行的功能：列出指定目录中的目录，以及文件 有哪些参数：a所有文件 l详细信息，包括大小写字节数，可读可写，可执行的权限等 4.目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？创建目录：mkdir创建文件：典型的如touch vi复制文件：cp 5.查看文件内容的命令有哪些？vi 文件名 编辑方式查看，可以修改cat 文件名 显示全部文件内容more 文件名 分页显示文件内容less 文件名 与more相似 可以往前翻页tail 文件名 仅查看尾部 可以指定行数head 文件名 仅查看头部 可以指定行数 6.移动文件 改名 用哪个命令？mv改名 将文件test改为new mv test new1 mv将目录 /usr/men中的所有文件移到当前目录 mv /usr/men/*. 7.复制 删除文件复制 cp [-adfilprsu] 源文件(source) 目标文件(destination) 删除 rm [fir] 文件或目录 8.常用的通配符和含义“？”可替代单个字符。 ·“*”可替代任意多个字符。 ·方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC] 15. 用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)wc 命令 - c 统计字节数。 – l 统计行数。 - w 统计字数。 9.终止进程kill -9 pid 10.查找自己所在终端的信息who am i","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"欢迎来到我的尬乐底master","slug":"hello-world","date":"2018-06-21T02:21:30.000Z","updated":"2018-06-22T10:28:57.000Z","comments":true,"path":"2018/06/21/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/21/hello-world/","excerpt":"","text":"庆祝今天博客刚刚搭建成功！！！","categories":[],"tags":[]}]}