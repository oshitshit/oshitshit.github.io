{"meta":{"title":"哦谢特谢特","subtitle":"苟利国家生死以","description":null,"author":"哦谢特谢特","url":"http://yoursite.com"},"pages":[{"title":"Linux","date":"2018-06-21T07:46:09.000Z","updated":"2018-06-21T07:46:09.000Z","comments":true,"path":"Linux/index.html","permalink":"http://yoursite.com/Linux/index.html","excerpt":"","text":""},{"title":"Favorite","date":"2018-06-23T14:49:05.000Z","updated":"2018-06-23T14:49:05.000Z","comments":true,"path":"favorite/index.html","permalink":"http://yoursite.com/favorite/index.html","excerpt":"","text":"还在施工中。。。 .hexo-image-steam-lazy {display:block;}.hexo-img-stream{width:90%;max-width:1100px;margin:3% auto}div.hexo-img-stream figure{background:#fefefe;box-shadow:0 1px 2px rgba(34,25,25,0.4);margin:0 0.05% 3%;padding:3%;padding-bottom:10px;display:inline-block;max-width:25%}div.hexo-img-stream figure img{border-bottom:1px solid #ccc;padding-bottom:15px;margin-bottom:5px}div.hexo-img-stream figure figcaption{font-size:.9rem;color:#444;line-height:1.5;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}div.hexo-img-stream small{font-size:1rem;float:right;text-transform:uppercase;color:#aaa}div.hexo-img-stream small a{color:#666;text-decoration:none;transition:.4s color}@media screen and (max-width:750px){.hexo-img-stream{column-gap:0}}我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 我命中注定的人 $('img.hexo-image-steam-lazy').lazyload({ effect:'fadeIn' });"}],"posts":[{"title":"欢迎来到我的Lab，助手呦！","slug":"hello-world","date":"2022-11-06T07:47:44.000Z","updated":"2018-06-22T14:55:35.000Z","comments":true,"path":"2022/11/06/hello-world/","link":"","permalink":"http://yoursite.com/2022/11/06/hello-world/","excerpt":"","text":"最近刚刚搭建了我的个人博客，准备把之前博客的文章慢慢迁移过来，我会看心情发一些学习和日常，还有推荐一些好看的动漫，有时会发一些小福利，做一些彩蛋什么的，希望大家常来玩！ el psy congroo","categories":[],"tags":[]},{"title":"Spring Security实现登录功能和原理","slug":"20180623-spring security登录及实现原理","date":"2018-06-23T12:47:44.000Z","updated":"2018-06-23T13:02:14.000Z","comments":true,"path":"2018/06/23/20180623-spring security登录及实现原理/","link":"","permalink":"http://yoursite.com/2018/06/23/20180623-spring security登录及实现原理/","excerpt":"写了几篇前端的东西差点忘了我是个写后台的。。这次我们来讲一下Spring Security实现登录功能和原理（基于springboot+jjwt），之前一直会用Spring Security但是对它的认证机制很是懵逼，最近看了源码才豁然开朗。如果需要源码可以留下邮箱。ps：篇幅较长，建议找个舒适的姿势看，不然就会像老夫一样歪着脖子看世界杯到现在还脖子痛。 spring security的配置","text":"写了几篇前端的东西差点忘了我是个写后台的。。这次我们来讲一下Spring Security实现登录功能和原理（基于springboot+jjwt），之前一直会用Spring Security但是对它的认证机制很是懵逼，最近看了源码才豁然开朗。如果需要源码可以留下邮箱。ps：篇幅较长，建议找个舒适的姿势看，不然就会像老夫一样歪着脖子看世界杯到现在还脖子痛。 spring security的配置 SecurityConfig 配置文件12345678910111213141516171819202122232425262728@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //跨站请求伪造禁用 http.csrf().disable(); // 基于token，所以不需要session http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); //不需要校验的文件 http.authorizeRequests() .antMatchers(\"/\", \"/*.html\", \"/favicon.ico\", \"/css/**\", \"/js/**\", \"/fonts/**\", \"/layui/**\", \"/img/**\", \"/v2/api-docs/**\", \"/swagger-resources/**\", \"/webjars/**\", \"/pages/**\", \"/druid/**\", \"/statics/**\") .permitAll().anyRequest().authenticated(); http.formLogin().loginPage(\"/login.html\").loginProcessingUrl(\"/login\") .successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler).and() .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint); http.logout().logoutUrl(\"/logout\").logoutSuccessHandler(logoutSuccessHandler); // 解决不允许显示在iframe的问题 http.headers().frameOptions().disable(); http.headers().cacheControl(); http.addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class);&#125;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());&#125; SecurityHandlerConfig（spring security处理器）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 登陆成功，返回token * */@Beanpublic AuthenticationSuccessHandler loginSuccessHandler() &#123; return new AuthenticationSuccessHandler() &#123; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Token token = tokenService.saveToken(loginUser); ResponseUtil.responseJson(httpServletResponse, HttpStatus.OK.value(),token); &#125; &#125;;&#125;/** * 登录失败 */@Beanpublic AuthenticationFailureHandler loginFailureHandler() &#123; return new AuthenticationFailureHandler() &#123; @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; String msg = null; if (e instanceof BadCredentialsException) &#123; msg = &quot;密码错误&quot;; &#125; else &#123; msg = e.getMessage(); &#125; ResponseInfo info = new ResponseInfo(HttpStatus.UNAUTHORIZED.value() + &quot;&quot;, msg); ResponseUtil.responseJson(httpServletResponse, HttpStatus.UNAUTHORIZED.value(), info); &#125; &#125;;&#125;/** * 未登录 */@Beanpublic AuthenticationEntryPoint authenticationEntryPoint() &#123; return new AuthenticationEntryPoint() &#123; @Override public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; ResponseInfo info = new ResponseInfo(HttpStatus.UNAUTHORIZED.value() + &quot;&quot;, &quot;请先登录&quot;); ResponseUtil.responseJson(httpServletResponse, HttpStatus.UNAUTHORIZED.value(), info); &#125; &#125;;&#125;/** * 退出处理 */@Beanpublic LogoutSuccessHandler logoutSuccessHandler() &#123; return new LogoutSuccessHandler() &#123; @Override public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; ResponseInfo info = new ResponseInfo(HttpStatus.OK.value() + &quot;&quot;, &quot;退出成功&quot;); String token = TokenFilter.getToken(httpServletRequest); tokenService.deleteToken(token); ResponseUtil.responseJson(httpServletResponse,HttpStatus.OK.value(),info); &#125; &#125;;&#125; Token拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Componentpublic class TokenFilter extends OncePerRequestFilter &#123; private static final String TOKEN_KEY = &quot;token&quot;; private static final Long MINUTES_10 = 10 * 60 * 1000L; @Autowired private TokenService tokenService; @Autowired private UserDetailsService userDetailsService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String token = getToken(request); if (StringUtils.isBlank(token)) &#123; LoginUser loginUser = tokenService.getLoginUser(token); if (loginUser != null) &#123; loginUser = checkLoginTime(loginUser); UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities()); SecurityContextHolder.getContext().setAuthentication(authenticationToken); &#125; &#125; filterChain.doFilter(request,response); &#125; /** * 校验过期时间 * 过期时间与当前时间对比，临近过期10分钟的话，自动刷新缓存 * * @return */ private LoginUser checkLoginTime(LoginUser loginUser) &#123; long expireTime = loginUser.getExpireTime(); long currentTime = System.currentTimeMillis(); if (expireTime - currentTime &lt;= MINUTES_10) &#123; String token = loginUser.getToken(); loginUser = (LoginUser) userDetailsService.loadUserByUsername(loginUser.getUsername()); loginUser.setToken(token); tokenService.refresh(loginUser); &#125; return loginUser; &#125; /** * 根据参数或者header获得token * @param request * @return */ public static String getToken(HttpServletRequest request) &#123; String token = request.getParameter(TOKEN_KEY); if (StringUtils.isBlank(token)) &#123; token = request.getHeader(TOKEN_KEY); &#125; return token; &#125;&#125; 具体实现1、前端调用登录方法123456789101112131415161718192021222324252627function login(obj) &#123; $(obj).attr(&quot;disabled&quot;, true); var username = $.trim($(&apos;#username&apos;).val()); var password = $.trim($(&apos;#password&apos;).val()); if (username == &quot;&quot; || password == &quot;&quot;) &#123; $(&quot;#info&quot;).html(&apos;用户名或者密码不能为空&apos;); $(obj).attr(&quot;disabled&quot;, false); &#125; else &#123; $.ajax(&#123; type : &apos;post&apos;, url : &apos;/login&apos;, data : $(&quot;#login-form&quot;).serialize(), success : function(data) &#123; localStorage.setItem(&quot;token&quot;, data.token); location.href = &apos;/index.html&apos;; &#125;, error : function(xhr, textStatus, errorThrown) &#123; var msg = xhr.responseText; var response = JSON.parse(msg); $(&quot;#info&quot;).html(response.message); $(obj).attr(&quot;disabled&quot;, false); &#125; &#125;); &#125;&#125; 2、我们在SecurityConfig 配置文件中的这段代码设置了对登录的处理。123http.formLogin().loginPage(\"/login.html\").loginProcessingUrl(\"/login\") .successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler).and() .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint); 3、后经过org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter这个拦截器的attemptAuthentication方法获取到前端的用户名和密码，具体的代码如下123456789101112131415161718192021222324public UsernamePasswordAuthenticationFilter() &#123; super(new AntPathRequestMatcher(\"/login\", \"POST\")); &#125; public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (this.postOnly &amp;&amp; !request.getMethod().equals(\"POST\")) &#123; throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod()); &#125; else &#123; String username = this.obtainUsername(request); String password = this.obtainPassword(request); if (username == null) &#123; username = \"\"; &#125; if (password == null) &#123; password = \"\"; &#125; username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125; &#125; 4、上面的方法只支持post请求，获取到用户名密码后构造未认证的UsernamePasswordAuthentication 后设置details然后通过AuthenticationManager（实际上为ProviderManager的authenticate方法）完成验证，该方法先循环遍历provider 找到具体执行该认证的provider 然后复制details 然后由具体的provider来完成认证，具体代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); AuthenticationException lastException = null; Authentication result = null; boolean debug = logger.isDebugEnabled(); Iterator var6 = this.getProviders().iterator(); while(var6.hasNext()) &#123; AuthenticationProvider provider = (AuthenticationProvider)var6.next(); if (provider.supports(toTest)) &#123; if (debug) &#123; logger.debug(\"Authentication attempt using \" + provider.getClass().getName()); &#125; try &#123; result = provider.authenticate(authentication); if (result != null) &#123; this.copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException var11) &#123; this.prepareException(var11, authentication); throw var11; &#125; catch (InternalAuthenticationServiceException var12) &#123; this.prepareException(var12, authentication); throw var12; &#125; catch (AuthenticationException var13) &#123; lastException = var13; &#125; &#125; &#125; if (result == null &amp;&amp; this.parent != null) &#123; try &#123; result = this.parent.authenticate(authentication); &#125; catch (ProviderNotFoundException var9) &#123; ; &#125; catch (AuthenticationException var10) &#123; lastException = var10; &#125; &#125; if (result != null) &#123; if (this.eraseCredentialsAfterAuthentication &amp;&amp; result instanceof CredentialsContainer) &#123; ((CredentialsContainer)result).eraseCredentials(); &#125; this.eventPublisher.publishAuthenticationSuccess(result); return result; &#125; else &#123; if (lastException == null) &#123; lastException = new ProviderNotFoundException(this.messages.getMessage(\"ProviderManager.providerNotFound\", new Object[]&#123;toTest.getName()&#125;, \"No AuthenticationProvider found for &#123;0&#125;\")); &#125; this.prepareException((AuthenticationException)lastException, authentication); throw lastException; &#125; &#125; 5、 具体的验证处理由DaoAuthenticationProvider的父类AbstractUserDetailsAuthenticationProvider的authenticate方法来完成，该方法先获取到登录的用户名，如果缓存中有UserDetails则从缓存中获取UserDetails如果没有则根据用户名和authentication获取UserDetails 后进行一系列验证成功后返回Authentication，具体代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.onlySupports\", \"Only UsernamePasswordAuthenticationToken is supported\")); String username = authentication.getPrincipal() == null ? \"NONE_PROVIDED\" : authentication.getName(); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); &#125; catch (UsernameNotFoundException var6) &#123; this.logger.debug(\"User '\" + username + \"' not found\"); if (this.hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; throw var6; &#125; Assert.notNull(user, \"retrieveUser returned null - a violation of the interface contract\"); &#125; try &#123; this.preAuthenticationChecks.check(user); this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); &#125; catch (AuthenticationException var7) &#123; if (!cacheWasUsed) &#123; throw var7; &#125; cacheWasUsed = false; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); this.preAuthenticationChecks.check(user); this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); &#125; this.postAuthenticationChecks.check(user); if (!cacheWasUsed) &#123; this.userCache.putUserInCache(user); &#125; Object principalToReturn = user; if (this.forcePrincipalAsString) &#123; principalToReturn = user.getUsername(); &#125; return this.createSuccessAuthentication(principalToReturn, authentication, user); &#125; 6、验证过程由DaoAuthenticationProvider的retrieveUser和additionalAuthenticationChecks方法来实现，具体代码如下12345678910111213141516171819protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; this.prepareTimingAttackProtection(); try &#123; UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); if (loadedUser == null) &#123; throw new InternalAuthenticationServiceException(\"UserDetailsService returned null, which is an interface contract violation\"); &#125; else &#123; return loadedUser; &#125; &#125; catch (UsernameNotFoundException var4) &#123; this.mitigateAgainstTimingAttack(authentication); throw var4; &#125; catch (InternalAuthenticationServiceException var5) &#123; throw var5; &#125; catch (Exception var6) &#123; throw new InternalAuthenticationServiceException(var6.getMessage(), var6); &#125; &#125; 123456789101112protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; if (authentication.getCredentials() == null) &#123; this.logger.debug(\"Authentication failed: no credentials provided\"); throw new BadCredentialsException(this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; else &#123; String presentedPassword = authentication.getCredentials().toString(); if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123; this.logger.debug(\"Authentication failed: password does not match stored value\"); throw new BadCredentialsException(this.messages.getMessage(\"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; &#125; &#125; 这个方法通过loadUserByUsername来获取到数据库中的用户信息，所以我们要自己重写实现UserDetailsService接口的loadUserByUsername方法，实现如下12345678910111213141516171819202122232425262728293031@Servicepublic class UserDetailsServiceImpl implements UserDetailsService&#123; @Autowired private UserService userService; @Autowired private PermissionDao permissionDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; SysUser user = userService.getUser(username); if (user == null) &#123; throw new AuthenticationCredentialsNotFoundException(\"用户名不存在\"); &#125; else if (user.getStatus() == Status.LOCKED) &#123; throw new LockedException(\"用户被锁定，请联系管理员\"); &#125; else if (user.getStatus() == Status.DISABLED) &#123; throw new DisabledException(\"用户已被封禁\"); &#125; LoginUser loginUser = new LoginUser(); BeanUtils.copyProperties(user, loginUser); List&lt;Permission&gt; permissions = permissionDao.listByUserId(user.getId()); loginUser.setPermissions(permissions); return loginUser; &#125;&#125; 通过loadUserByUsername获取到数据库的用户信息在通过上面的两个方法和前端传过来的用户信息进行比对就完成了登录认证。 认证完成后成功失败等一系列处理在SecurityHandlerConfig进行处理，成功后将token储存到redis中。 可能说的不是很清楚，如果有搞不明白的小伙伴可以来找我一起讨论。最近一直在和老王研究微服务，等上线后我会写一些spring cloud相关的东西。","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/categories/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://yoursite.com/tags/Spring-Security/"}]},{"title":"网络工程期末考试 （答案整理：胡立阳老哥）","slug":"网络工程期末考试","date":"2018-06-23T07:47:44.000Z","updated":"2018-06-23T13:22:44.000Z","comments":true,"path":"2018/06/23/网络工程期末考试/","link":"","permalink":"http://yoursite.com/2018/06/23/网络工程期末考试/","excerpt":"唉。。。想起来还有期末考试这种东西，算了反正就这一个网络工程。此处感谢胡立阳老哥，还有搬运工龙哥。 一、问答题1、根据《综合布线系统工程设计规范》（GB 50311-2007）标准，并兼顾行业习惯，将综合布线系统划分为哪七个子系统？工作区子系统、建筑群子系统、配线子系统、干线子系统、电信间、设备间、进线间。 此处默念二十遍。 2、下图中展示的综合布线系统哪几个系统，各缩写字母代表什么？CD：建筑群配线设备BD：建筑物配线设备FD：电信间配线设备CP：集合点TO：信息点TE：终端设备","text":"唉。。。想起来还有期末考试这种东西，算了反正就这一个网络工程。此处感谢胡立阳老哥，还有搬运工龙哥。 一、问答题1、根据《综合布线系统工程设计规范》（GB 50311-2007）标准，并兼顾行业习惯，将综合布线系统划分为哪七个子系统？工作区子系统、建筑群子系统、配线子系统、干线子系统、电信间、设备间、进线间。 此处默念二十遍。 2、下图中展示的综合布线系统哪几个系统，各缩写字母代表什么？CD：建筑群配线设备BD：建筑物配线设备FD：电信间配线设备CP：集合点TO：信息点TE：终端设备 3、网络工程建设可简单分为三个阶段，交换机可分为几类？网络规划与设计、工程实施与系统集成、工程竣工验收与技术培训。 （1） 按网络覆盖范围划分：广域网交换机、局域网交换机。 （2） 按照传输介质和数据传输速率划分： （3） 按交换机工作的协议层次划分：第二层交换机、第三层交换机、第四层交换机、第七层交换机； （4） 按交换机的端口结构划分：固定式交换机、模块化交换机； （5） 按网络分层结构划分：核心层交换机、汇聚层交换机、接入层交换机； （6） 按外观划分：机箱式交换机、机架式交换机、桌面型交换机； （7） 按交换机应用规模层次划分：企业级交换机、校园网交换机、部门级交换机、工作组交换机； （8） 按是否支持网管功能：网管型和非网管型两大类； （9） 按是否可以堆叠：可堆叠和不可堆叠两大类； 4、交换机中的转发表是如何建立的？ 当交换机接收到数据后，首先对数据帧拆包，将数据帧的源MAC拆分出来，如果交换机内部的存储器中没有此MAC地址，则将该MAC地址与其进入的端口保存起来，形成一个映射，这些信息就是MAC地址表。 二、交换机上VLAN的划分使用一台交换机和两台PC机，还将其中PC1作为控制台终端，使用Console口配置方式；使用两根网线分别将PC1和PC2连接到交换机的RJ-45接口上。要求：在交换机上划分两个基于端口的VLAN：VLAN100，VLAN200。使得VLAN100的成员能够互相访问，VLAN200的成员能够互相访问；VLAN100和VLAN200成员之间不能互相访问。PC1和PC2的网络设置为：PC1、PC2接在VLAN100的成员端口1~8上，两台PC互相可以ping通；PC1、PC2接在VLAN的成员端口9~16上，两台PC互相可以ping通；PC1接在VLAN100的成员端口1~8上，PC2接在VLAN200的成员端口9~16上，则互相ping不通。123456789101112131415&lt;HUAWEI&gt; system-view[HUAWEI] vlan batch 100 200[HUAWEI] port-group pg1[HUAWEI-port-group-pg1] group-member E0/0/1 to E0/0/8[HUAWEI-port-group-pg1] port link-type access[HUAWEI-port-group-pg1] port default vlan 100[HUAWEI] port-group pg2[HUAWEI-port-group-pg1] group-member E0/0/9 to E0/0/16[HUAWEI-port-group-pg1] port link-type access[HUAWEI-port-group-pg1] port default vlan 200int vlanif 1ip add 192.168.3.11 24 三、跨交换机VLAN要求：在交换机A和交换机B上分别划分两个基于端口的VLAN：VLAN100，VLAN200。使得交换机之间VLAN100的成员能够互相访问，VLAN200的成员能够互相访问；VLAN100和VLAN200成员之间不能互相访问。PC1和PC2的网络设置为： PC1、PC2分别接在不同交换机VLAN100的成员端口1~8上，两台PC互相可以ping通；PC1、PC2分别接在不同交换机VLAN的成员端口9~16上，两台PC互相可以ping通；PC1和PC2接在不同VLAN的成员端口上则互相ping不通。在交换机A配置：12345678910111213141516&lt;HUAWEI&gt; system-view[HUAWEI] port-group pg1[HUAWEI-port-group-pg1] group-member E0/0/1 to E0/0/8[HUAWEI-port-group-pg1] port link-type access[HUAWEI-port-group-pg1] port default vlan 100[HUAWEI] port-group pg2[HUAWEI-port-group-pg1] group-member E0/0/9 to E0/0/16[HUAWEI-port-group-pg1] port link-type access[HUAWEI-port-group-pg1] port default vlan 200int e 0/0/24port link-type trunkport trunk allow-pass vlan 100 200在交换机B配置：与A类似。 四、链路聚合SwitchA和SwitchB通过以太链路分别都连接VLAN10和VLAN20的网络，且SwitchA和SwitchB之间有较大的数据流量。用户希望SwitchA和SwitchB之间能够提供较大的链路带宽来使相同VLAN间互相通信。配置手工模式链路聚合实现上述要求。在SwitchA和SwitchB上创建Eth-Trunk接口并加入成员接口123456789101112131415161718192021&lt;HUAWEI&gt; system-view[HUAWEI] sysname SwitchA[SwitchA] interface eth-trunk 1[SwitchA-Eth-Trunk1] trunkport gigabitethernet 0/0/1 to 0/0/3&lt;HUAWEI&gt; system-view[HUAWEI] sysname SwitchB[SwitchB] interface eth-trunk 1[SwitchB-Eth-Trunk1] trunkport gigabitethernet 0/0/1 to 0/0/3创建VLAN并将接口加入VLAN。SwitchB的配置与SwitchA类似：[SwitchA] vlan batch 10 20[SwitchA] interface gigabitethernet 0/0/4[SwitchA-GigabitEthernet0/0/4] port link-type trunk[SwitchA-GigabitEthernet0/0/4] port trunk allow-pass vlan 10[SwitchA] interface gigabitethernet 0/0/5[SwitchA-GigabitEthernet0/0/5] port link-type trunk[SwitchA-GigabitEthernet0/0/5] port trunk allow-pass vlan 20配置Eth-Trunk1接口允许VLAN10和VLAN20通过。SwitchB的配置与SwitchA类似。[SwitchA] interface eth-trunk 1[SwitchA-Eth-Trunk1] port link-type trunk[SwitchA-Eth-Trunk1] port trunk allow-pass vlan 10 20 五、VLAN间通信在交换机LSW1上有两个VLAN（VLAN10和VLAN20），每个VLAN分配的IP地址块分别是192.168.1.0/24和192.168.2.0/24。为使VLAN间通信，在路由器的E0/0/0上配置子接口。要求：在交换机上配置VLAN10，将G0/0/2加入VLAN10；配置VLAN20，将G0/0/9加入VLAN20；配置交换机上的G0/0/1端口；配置路由器,实现VLAN终接。1234567891011121314151617181920交换机配置如下：vlan batch 10 20interface GigabitEthernet0/0/1port link-type trunkport trunk allow-pass vlan 10 20interface GigabitEthernet0/0/2port link-type accessport default vlan 10interface GigabitEthernet0/0/9port link-type accessport default vlan 20路由器配置如下：interface Ethernet0/0/0.1dot1q termination vid 10ip address 192.168.1.1 255.255.255.0arp broadcast enableinterface Ethernet0/0/0.2dot1q termination vid 20ip address 192.168.2.1 255.255.255.0arp broadcast enable 六、Trunk接口配置1、根据上图所示，在交换机SW1和SW2上创建VLAN10和VLAN20，将连接PC的接口配置为Access类型，并加入到相应的VLAN中。2、将交换机之间互联的链路配置为Trunk，使得该链路能够承载多VLAN流量。12345678910111213SW1配置如下：vlan batch 10 20interface gigabitEthernet 0/0/1port link-type accessport default vlan 10interface gigabitEthernet 0/0/2port link-type accessport default vlan 20interface gigabitEthernet 0/0/24port link-type trunkport trunk allow-pass vlan 10 20SW2配置如下：同SW1配置 七、使用多层交换机实现二层交换机VLAN之间的路由要求：在交换机A和交换机B上分别划分两个基于端口的VLAN：VLAN100，VLAN200。在交换机C上也划分两个基于端口的VLAN：VLAN100，VLAN200。把端口1和端口2都设置成Trunk口。交换机A的24口连接交换机C的1口，交换机B的24口连接交换机C的2口。PC1-PC4的网络设置为：1234567891011121314151617181920212223242526272829303132交换机A(交换机B类似)：vlan batch 100 200port-group pg1group-member e1 to e8port link-type accessport default vlan 100port-group pg2group-member e9 to e16port link-type accessport default vlan 200int e24port link-type trunkport trunk allow vlan 100 200交换机C：vlan batch 100 200int e1/1port link-type trunkport trunk allow vlan 100 200int e1/2port link-type trunkport trunk allow vlan 100 200int vlanif 100ip add 192.168.10.1 24int vlanif 200ip add 192.168.20.1 24 八、广域网数据链层协议的配置要求：左侧路由器S2/0地址1.1.1.1/24，f0/0地址192.168.1.1/24； 右侧路由器S1/0地址1.1.1.2/24，f0/0地址192.168.2.1/24；采用PPP封装，无验证。配置路由器串行接口封装，并配置IP地址1234567891011121314151617左侧路由器配置：system-viewinterface serial 4/0/0link-protocol pppip address 1.1.1.1 24interface gigabitEthernet 0/0/0ip address 192.168.1.1 24quitip route-static 192.168.2.0 24 1.1.1.2右侧路由器配置：system-viewinterface serial 4/0/0link-protocol pppip address 1.1.1.2 24interface gigabitEthernet 0/0/0ip address 192.168.2.1 24ip route-static 192.168.1.0 24 1.1.1.1 九、RIP配置在上图所示互连网中，路由器AR1与AR3使用同步串口相连，要求数据链层协议使用PPP；路由器AR2与AR3使用同步串口相连，要求数据链层协议使用帧中继，且DLCI值为100。每个路由器连接了一个以太局域网。路由器AR1端口G0/0/1和S4/0/0的IP地址分别为192.168.1.1/24和192.168.2.1/24；路由器AR3端口S4/0/0、G0/0/2和S4/0/1的IP地址分别为192.168.2.2/24、192.168.3.1/24和192.168.4.1/24；路由器AR2端口S4/0/0和G0/0/1的IP地址分别为192.168.4.2/24和192.168.5.1/24。同时要求各路由器使用RIP协议实现网络互通。123456789101112131415161718192021222324252627282930313233343536373839404142434445路由器AR1配置：system-viewint s4/0/0link-protocol pppip address 192.168.2.1 24int g0/0/1ip address 192.168.1.1 24quitrip 1version 2network 192.168.1.0network 192.168.2.0路由器AR2配置：sysint s4/0/0link-protocol frip address 192.168.4.2 24fr map ip 192.168.4.1 100int g0/0/1ip address 192.168.5.1 24quitrip 1version 2network 192.168.4.0network 192.168.5.0peer 192.168.4.1路由器AR3配置：sysint s4/0/0link-protocol pppip address 192.168.2.2 24int s4/0/1link-protocol frfr interface-type dcefr map ip 192.168.4.2 100ip address 192.168.4.1 24int g0/0/2ip address 192.168.3.1 24quitrip 1version 2network 192.168.2.0network 192.168.3.0network 192.168.4.0peer 192.168.4.2 十、OSPF配置设备接口编号及IP编址如下图所示，要求R1-R2之间运行RIPv2，R2-R3之间运行OSPF；在R2上完成路由重发布的配置，使得全网的路由能够互通。完成所有配置后，要求PC1与PC2能够互访。12345678910111213141516171819202122232425262728293031323334353637路由器R1配置：system-viewinterface GigabitEthernet 0/0/0ip address 192.168.12.1 24interface GigabitEthernet 0/0/1ip address 192.168.1.254 24rip 1version 2network 192.168.12.0network 192.168.1.0路由器AR2配置：system-view#完成接口IP的配置：interface GigabitEthernet 0/0/0ip address 192.168.12.2 24interface GigabitEthernet 0/0/1ip address 192.168.23.2 24#在R2的GE0/0/0上激活RIPv2：rip 1version 2network 192.168.12.0import-route ospf 1#在R2的GE0/0/1上激活OSPF：ospf 1 router-id 2.2.2.2area 0network 192.168.23.0 0.0.0.255import-route rip 1路由器AR3配置：system-viewinterface GigabitEthernet 0/0/0ip address 192.168.23.3 24interface GigabitEthernet 0/0/1ip address 192.168.2.254 24ospf 1 router-id 3.3.3.3area 0network 192.168.23.0 0.0.0.255network 192.168.2.0 0.0.0.255 十一、多区域及AS间OSPF配置在下图中ROUTE-C是ASBR，其E0/2与外部相连，不在OSPF的自治系统内。在外部网络中，ROUTE-C和ROUTE-D使用RIP协议。自治系统内使用OSPF协议。假设各路由器的基础配置已配好，试配置OSPF和RIP使网络互通。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950路由器B配置：int loopback 0ip address 11.10.10.1 24quitint s4/0/0ip address 172.16.24.2 24ospf 1area 0network 172.16.24.0 0.0.0.255路由器A配置：int loopback 0ip address 10.10.10.1 24int s4/0/0ip address 172.16.24.1 24ospf 1area 0network 172.16.24.0 0.0.0.255int s4/0/1ip address 172.16.25.1 24ospf 1area 1network 172.16.25.0 0.0.0.255路由器C配置：int loopback 0ip address 12.10.10.1 24int s4/0/0ip address 172.16.25.2 24ospf 1import-route riparea 1network 172.16.25.0 0.0.0.255int g0/0/0ip address 192.168.1.1 24rip 1version 2import-route ospfnetwork 192.168.1.0路由器D配置：sysint g0/0/0ip address 192.168.1.2 24int g0/0/1ip address 192.168.2.1 24rip 1version 2network 192.168.1.0network 192.168.2.0","categories":[],"tags":[]},{"title":"DOM事件流 事件代理  JS作用域和作用域链","slug":"20180622-js原型链","date":"2018-06-22T14:00:44.000Z","updated":"2018-06-22T15:00:15.000Z","comments":true,"path":"2018/06/22/20180622-js原型链/","link":"","permalink":"http://yoursite.com/2018/06/22/20180622-js原型链/","excerpt":"内马尔进球了 我，里奥·谢特，现在慌得一批（我才不是梅西黑粉）这次我们来看下dom事件流，事件代理和js中的作用域作用域链。 1.DOM事件流dom事件简单地说就是定义了一些JavaScript函数使他们能够响应页面元素发生的变化，如click事件。 事件的生命周期分为三个阶段 捕捉 目标 冒泡 a)捕捉阶段当某个事件被触发的时候，浏览器会找到涉及的元素，涉及的元素被称为目标，浏览器会先触发外层事件的处理器，最后才会轮到目标事件处理器。","text":"内马尔进球了 我，里奥·谢特，现在慌得一批（我才不是梅西黑粉）这次我们来看下dom事件流，事件代理和js中的作用域作用域链。 1.DOM事件流dom事件简单地说就是定义了一些JavaScript函数使他们能够响应页面元素发生的变化，如click事件。 事件的生命周期分为三个阶段 捕捉 目标 冒泡 a)捕捉阶段当某个事件被触发的时候，浏览器会找到涉及的元素，涉及的元素被称为目标，浏览器会先触发外层事件的处理器，最后才会轮到目标事件处理器。 b)目标阶段捕获阶段完成后，浏览器触发目标元素上任何已经添加的事件类型监听器。 c)冒泡阶段冒泡阶段与捕获阶段顺序正好相反，在这个阶段，浏览器会优先处理目标的事件处理器，然后一层层往外处理其余的事件处理器。 总结来说就是：冒泡事件按照最特定的事件目标到最不特定的事件目标的顺序触发。捕获事件是从最不特定的开始触发到最特定的事件。 看下这张图更助于理解 在JS中，绑定的事件默认的执行时间是在冒泡阶段执行，而非在捕获阶段，必须要理解 不过我们可以通过绑定事件时，指定事件执行时间是在冒泡阶段还是捕获阶段。 obj.addEventListener(event,function(){},bool) bool:false，代表冒泡阶段执行 bool:true，代表捕获阶段执行 JS在默认情况下获取事件后，就开始从根元素开始捕获所有该事件的监听对象，然后在冒泡阶段逐一执行。捕获阶段是在冒泡阶段前面 阻止冒泡 w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true； 阻止默认行为 w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false; ps:onclick,click,on()的优先关系：onclick&gt;click&gt;on()； onclick和click绑定的事件，彼此之间遵守事件冒泡规则，从内到外触发； on()绑定的事件，总是晚于onclick和click绑定的事件触发； 2.事件代理当我们需要对很多元素添加事件的时候，可以通过将事件添加到他的父节点而将事件委托给父节点来触发处理函数，这主要得益于浏览器的冒泡机制。123456789101112131415 &lt;ul id=\"parent-list\"&gt; &lt;li id=\"p1\"&gt;Item 1&lt;/li&gt; &lt;li id=\"p1\"&gt;Item 2&lt;/li&gt; &lt;li id=\"p1\"&gt;Item 3&lt;/li&gt; &lt;li id=\"p1\"&gt;Item 4&lt;/li&gt; &lt;/ul&gt; //下面实现事件代理 //获取父节点 为他添加一个click事件 document.getElementById(\"parent-list\").addEventListener(\"click\",function(e)&#123; //检查事件源e.target是否为li if(e.target &amp;&amp; e.target.nodeName.toUpperCase == \"LI\") //处理过程 console.log(\"List item\",e.target.id.replace(\"p\"),\"was clicked!\");&#125;); 为父节点添加一个click事件，当子节点被点击的时候，click事件会从子节点开始向上冒泡，通过判断e.target.nodeName来判断是否为我们需要处理的节点。并且通过e.target拿到了被点击的li节点。从而获取到相应的信息，并做处理。 我们可以用jQuery的delegate函数更为方便的处理1234$(\"#link-list\").delegate(\"a\",\"click\",function()&#123; //\"$(this)\"是被点击的节点 console.log(\"you clicked a link!\",$(this));&#125;); 3.JavaScript中的作用域和作用域链JavaScript函数的作用域：函数内的区域，就是这个函数的作用域，变量和函数在这个区域都可以访问操作。最外层函数外的区域叫全局作用域，函数内的区域叫局部作用域。 JavaScript变量的作用域：在源代码中变量所在的区域就是这个变量的作用域，变量在这个区域内可以被访问操作。在全局作用域上定义的变量叫全局变量，在函数内定义的变量叫局部变量（函数内声明但不加var 视为全局变量） 作用域链：作用域链（Scope Chain）是JavaScript内部的一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域，理解作用域链的作用原理。 执行环境：执行环境也被称为上下文，当解析器进入ECMAScript的可执行代码，解析器就进入一个执行环境，活动的执行环境组成一个逻辑上的栈，在这个逻辑栈顶部的执行环境就是当前运行的执行环境。 ps：ECMAScriptt中有三种可执行代码，Global、Function和Eval： eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript)字符串。看下面的例子： eval(“alert(‘专业做网站’)”)； 这行代码的作用等价于下面这行代码： alert(“专业做网站”); 全局环境即是Global可执行代码，函数即是Function可执行代码。逻辑栈是一种特殊的数据存储格式，特点是‘先进后出，后进先出’，添加数据会先压入逻辑栈顶部，删除数据必须先从顶部开始删除。 变量对象(Variable Object)、活动对象(Activation Object)和Arguments对象(Arguments Object) 每个执行环境都有一个与之关联的变量对象，当解析器进入执行环境时，就会创建一个变量对象，变量对象保存着在当前执行环境中声明的变量和函数的引用。 变量对象是一个抽象的概念，在不同的执行环境中，变量对象有不同的身份，在解析器进入任何执行环境之前，就已经创建了一个Global对象，当解析器进入全局执行环境时，Global对象就充当变量对象，当解析器进入一个函数时，就会创建一个活动对象充当变量对象。 解析器处理代码时的两个阶段:JavaScript解析器是一段一段解析处理代码的，解析器处理代码时的两个阶段：解析代码和执行代码。 当解析器进入执行环境时，变量对象就会添加执行环境中声明的变量和函数作为它的属性，这就意味着变量和函数在声明之前已经可用，变量值为undefined，这就是变量和函数声明提升(Hoisting)的原因，与此同时作用域链和this确定，此过程为解析阶段，俗称预解析。接着解析器开始执行代码，为变量添加相应值的引用，得到执行结果，此过程为执行阶段。 举个栗子12345var a=123;var b=\"abc\";function c()&#123; alert('11');&#125; 上述全局环境中的代码解析执行后，会将Global对象作为变量对象，保存以下数据。 12345678function testFn(a)&#123; var b=\"123\"; function c()&#123; alert(\"abc\"); &#125;&#125;testFn(10); 当解析器进入函数执行环境时，则会创建一个活动对象作为变量对象，活动对象还会创建一个Arguments对象，arguments对象是一个参数集合，用来保存参数，这就是我们写函数时可以使用arguments[0]等来使用参数的原因。 作用域链：每个执行环境都有一个与之关联的作用域链，当解析器进入执行环境时被定义，作用域链是一个对象列表，用来检索各个变量对象中的变量和函数，这样可以保证执行环境有权访问哪些变量和函数，举个栗子。12345678910111213var a='123';function testFn(b)&#123; var c='abc'; function testFn2()&#123; var d='efg'; alert(a); &#125; testFn2();&#125;testFn(10); testFn2内未声明变量a，为什么testFn2能调用全局变量a？整个过程是怎么发生的呢？请看下图。 当解析器进入全局执行环境时，调用变量和函数时只在Global对象中查找。 当解析器进入testFn函数执行环境时，函数内部属性[[scope]]中首先填入Global对象，然后将testFn活动对象添加到Global对象之前，形成一个作用域链当解析器进入testFn2函数执行环境时，函数内部属性[[scope]]首先填入父级的作用域链，然后再将当前的testFn2活动对象添加到作用域链的前端，形成一个新的作用域链。 testFn2调用变量a时，首先在当前的testFn2活动对象中查找，如果没有找到就顺着作用域链向上，在testFn活动对象中查找变量a，如果没有找到再顺着作用域链向上查找，直到在最后Global对象中找到为止，否则报错。所以函数内部可以调用外部环境的变量，外部环境不能调用函数内部的变量，这就是作用域特性的原理。 参考文献：作者未知\u0000\u0000\b","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript闭包初步了解","slug":"20180622-js闭包","date":"2018-06-22T09:47:44.000Z","updated":"2018-06-22T10:30:57.000Z","comments":true,"path":"2018/06/22/20180622-js闭包/","link":"","permalink":"http://yoursite.com/2018/06/22/20180622-js闭包/","excerpt":"没错，在下就是这么勤劳 ，这里来总结一下js闭包，搬运自阮大佬的日志 闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。1.变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。","text":"没错，在下就是这么勤劳 ，这里来总结一下js闭包，搬运自阮大佬的日志 闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。1.变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 1234567var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 12345 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！1234567 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 2.如何从外部读取局部变量出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789101112131415function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 3.闭包的概念上面代码中的f2函数，就是闭包。 各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我(阮大佬)的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 4.闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。123456789101112131415161718192021 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 5.使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 常见陷阱12345678910111213function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; console.log(funcs[i]());&#125; 乍一看，以为输出 0~9 ，万万没想到输出10个10？ 这里的陷阱就是：函数带()才是执行函数， 单纯的一句 var f = function() { alert(‘Hi’); }; 是不会弹窗的，后面接一句 f(); 才会执行函数内部的代码。上面代码翻译一下就是：12345678910111213var result = new Array(), i;result[0] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！result[1] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！...result[9] = function()&#123; return i; &#125;; //没执行函数，函数内部不变，不能将函数内的i替换！i = 10;funcs = result;result = null;console.log(i); // funcs[0]()就是执行 return i 语句，就是返回10console.log(i); // funcs[1]()就是执行 return i 语句，就是返回10...console.log(i); // funcs[9]()就是执行 return i 语句，就是返回10 为什么只垃圾回收了 result，但却不收了 i 呢？ 因为 i 还在被 function 引用着啊。好比一个餐厅，盘子总是有限的，所以服务员会去巡台回收空盘子，但还装着菜的盘子他怎么敢收？ 当然，你自己手动倒掉了盘子里面的菜（=null），那盘子就会被收走了，这就是所谓的内存回收机制。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"前端跨域问题的解决方案","slug":"20180623-前端跨域问题的解决方法","date":"2018-06-22T07:47:44.000Z","updated":"2018-06-22T10:28:14.000Z","comments":true,"path":"2018/06/22/20180623-前端跨域问题的解决方法/","link":"","permalink":"http://yoursite.com/2018/06/22/20180623-前端跨域问题的解决方法/","excerpt":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧 1.什么是跨域 域名 说明 是否跨域 http://www.a.com/a.js http://www.a.com/b.js 同一域名 否 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名文件夹不同 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名端口不同 是 http://www.a.com/a.js https://www.a.com/b.js 同一域名协议不同 是 http://www.a.com/a.js http://70.32.92.74/b.js 对应ip相同 是 http://www.a.com/a.js http://script.a.com/b.js 子域名不同 是 http://www.bilibili.com/a.js http://www.a.com/b.js 不同域名 是 2.解决方法1.JSONP实现跨域JSONP是json with padding（填充式json或参数式json）的简称","text":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧 1.什么是跨域 域名 说明 是否跨域 http://www.a.com/a.js http://www.a.com/b.js 同一域名 否 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名文件夹不同 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名端口不同 是 http://www.a.com/a.js https://www.a.com/b.js 同一域名协议不同 是 http://www.a.com/a.js http://70.32.92.74/b.js 对应ip相同 是 http://www.a.com/a.js http://script.a.com/b.js 子域名不同 是 http://www.bilibili.com/a.js http://www.a.com/b.js 不同域名 是 2.解决方法1.JSONP实现跨域JSONP是json with padding（填充式json或参数式json）的简称JSONP包含两部分：回调函数和数据。 JSONP实现跨域请求的原理是动态创建&lt;script&gt;标签，然后利用&lt;script&gt;的src 不受同源策略约束来跨域获取数据1234567function handleResponse(response)&#123; console.log(response.data);&#125;var script = document.createElement('script');script.src = 'http:/www.domain.com/json?callback=handleResponse';document.body.insertBefore(script, document.body.firstChild);//handleResonse(&#123;\"data\": \"zhe\"&#125;) 具体流程：通过script标签请求时后台根据相应的参数(json,handleResponse)来生成相应的json数据(handleResponse({&quot;data&quot;: &quot;zhe&quot;}))，最后这个返回的json数据就会被放在当前js文件中被执行。 JSONP的缺陷：1、请求代码存在安全隐患。借助JSONP有可能进行跨站请求伪造(CSRF)攻击。2、无法确定jsonp成功与否3、只能实现get请求1234567$.ajax(&#123; url: 'http://www.domain.com/json', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;); 2.document.domain + iframe实现跨域这个方案只适用于主域名相同，子域名不同的跨域处理。 原理是通过js强制设置document.domain 为基础主域。 123456789101112//父窗口www.domain.com/a.html&lt;iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt;//子窗口child.domain.com/b.html&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 3.location.hash+iframe实现跨域原理是利用location.hash来进行传值。 假设域名a.com下的文件cs1.html要和domain.com域名下的cs2.html传递信息。1) cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向domain.com域名下的cs2.html页面2) cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据3) 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //先是a.com下的文件cs1.html文件：function startRequest()&#123; var ifr = document.createElement('iframe'); ifr.style.display = 'none'; ifr.src = 'http://www.domain.com/lab/cscript/cs2.html#paramdo'; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : ''; if (console.log) &#123; console.log('Now the data is '+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000);//cnblogs.com域名下的cs2.html://模拟一个简单的参数处理操作switch(location.hash)&#123; case '#paramdo': callBack(); break; case '#paramset': //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = 'somedata'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = 'http://a.com/test/cscript/cs3.html#somedata'; // 注意该文件在\"a.com\"域下 document.body.appendChild(ifrproxy); &#125;&#125;//a.com下的域名cs3.html//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 4. window.name + iframe实现跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 原理是通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//1.）a.html：(www.domain1.com/a.html)var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data);&#125;);//2.）proxy.html：(www.domain1.com/proxy....//中间代理页，与a.html同域，内容为空即可。//3.）b.html：(www.domain2.com/b.html)&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 5.postMessage实现跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 12345678910111213141516171819202122232425262728293031323334//1.）a.html：(www.domain1.com/a.html)&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt;//2.）b.html：(www.domain2.com/b.html)&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; 6.CORS（跨域资源共享）实现跨域CORS是通过一系列特殊的HTTP头来解决这一问题，这些http头信息可以允许双方判断请求成功或者失败 在发送跨域HTTP请求时，支持CORS的浏览器会引入额外的Origin头信息来指定请求的源。这个头信息需要包含三个部分——协议、域名和端口 服务端的工作是检查头信息是否接受该请求。如果请求被接受，那么需要返回一个包含Access-Control-Allow-Origin，其值与客户端Origin值相同的响应头 如果资源是公共的允许任何源发送请求，服务器可以返回一个通配符Access-Control-Allow-Origin: *如果匹配成功，那么浏览器将会继续处理这个请求，否则禁止该请求。123456789101112131415161718192021222324252627282930//1.）原生ajax// 前端设置是否带cookiexhr.withCredentials = true;示例代码：var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;;//2.）jQuery ajax$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); java中后台可以这样设置12345 //导入包：import javax.servlet.http.HttpServletResponse; //接口参数中定义：HttpServletResponse responseresponse.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\"); // 若有端口需写全（协议+域名+端口）response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); 7.Nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 配置信息：123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 前端代码12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); node.js后台 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 8.Web Sockets实现跨域web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。 12345var socket = new WebSockt('ws://www.domain.com');//http-&gt;ws; https-&gt;wsssocket.send('hello WebSockt');socket.onmessage = function(event)&#123; var data = event.data;&#125; 参考资料阮一峰大佬的CORS 详解","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"web性能优化","slug":"Web性能优化","date":"2018-06-21T15:47:44.000Z","updated":"2018-06-22T14:50:47.000Z","comments":true,"path":"2018/06/21/Web性能优化/","link":"","permalink":"http://yoursite.com/2018/06/21/Web性能优化/","excerpt":"Web性能优化1、 减少http请求a) 在浏览器和服务器发生通信的时候 就已经消耗了大量的时间b) 网速相同的条件下 下载一个100kb的图片比下载两个50kb的图片要快c) 减少http请求的主要手段是合并css 合并JavaScript 合并图片","text":"Web性能优化1、 减少http请求a) 在浏览器和服务器发生通信的时候 就已经消耗了大量的时间b) 网速相同的条件下 下载一个100kb的图片比下载两个50kb的图片要快c) 减少http请求的主要手段是合并css 合并JavaScript 合并图片 2、 使用浏览器缓存a) 一个网站中 css js logo 图标这些静态资源文件更新的频率都比较低 如果将这些文件缓存在浏览器中可以极好地改善型性能b) 通过设置http头中的cache-control和expires属性 可以设定浏览器缓存c) 在某些时候 静态资源文件变化需要及时应用到客户端浏览器 这种情况 可以通过改变文件名称实现 即更新js文件不是更新js文件内容d) 使用留恋其缓存策略的网站在更新静态资源时 应采用分批次更新的方法 比如需要更新10个图标文件 不宜把10个文件一次全部更新 应该一个文件一个文件逐步更新 并有一定的间隔时间 以免浏览器突然大量缓存失效 3、 服务端启用压缩4、 css放在页面最上面 js放在页面最下面a) 浏览器会在下载完全部css之后才对整个页面进行渲染 因此最好的做法是将css放在页面最上面 让浏览器尽快下载cssb) Js则相反 浏览器在加载js后立即执行 有可能会阻塞整个页面 造成页面显示缓慢 因此js最好放在页面最下面 但如果解析页面的时候就需要用到js 这里就不适合放在底部了 5、 精简css和js文件a) css和js压缩 减少下载的文件体积 常用的方式是使用 yui compressor 它的特点是：移除注释 移除额外的空格 细微的优化 标识符替换b) 压缩js java -jar yuicompressor-2.4.2.jar api.js&gt;api.min.js 压缩css java -jar yuicompressor-2.4.2.jar style.css&gt;style.min.css 6、 减少对dom的操作a) 对dom操作的代价是高昂的b) 修改和访问dom元素会造成页面的重绘和重排 造成重绘重排的原因i. 修改domii. 修改样式表iii. 用户事件c) 网页生成的过程大致可以分为五个步骤i. html转换成domii. css代码转换成cssomiii. 结合dom和cssom 生成一棵渲染树iv. 生成布局 即将所有渲染树的所有节点进行平面合成v. 将布局绘制在屏幕上 7、 使用json格式进行数据交换8、 减少cookie传输a) 因为cookie是本地的磁盘文件 每次浏览器都会去读取相应的cookie所以建议去除不必要的cookie 使cookie体积尽量小 9、 使用cdn加速a) cdn全称是content delivery network 即内容分发网络b) cdn本质仍然是一个缓存 而且将数据缓存在离用户最近的地方 使用户最快的获取数据c) cdn能够缓存的一般般是静态资源 如图片 文件 css script脚本 静态网页d) 实时性不好使cdn的缺陷","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"linux中常见的指令","slug":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？","date":"2018-06-21T12:47:44.000Z","updated":"2018-06-21T14:31:14.000Z","comments":true,"path":"2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","link":"","permalink":"http://yoursite.com/2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","excerpt":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？ 查看当前进程：ps 查看负载情况：free 查看内存的使用情况 top 动态显示cpu的负载情况 执行退出：exit 查看当前路径：pwd","text":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？ 查看当前进程：ps 查看负载情况：free 查看内存的使用情况 top 动态显示cpu的负载情况 执行退出：exit 查看当前路径：pwd 2.如何清屏？怎么退出当前命令？怎么执行s会面？ 清屏：clear 退出当前：ctrl+c 执行睡眠：ctrl+z fg恢复后台 3.ls命令执行什么功能？可以带哪些参数？ ls执行的功能：列出指定目录中的目录，以及文件 有哪些参数：a所有文件 l详细信息，包括大小写字节数，可读可写，可执行的权限等 4.目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？创建目录：mkdir创建文件：典型的如touch vi复制文件：cp 5.查看文件内容的命令有哪些？vi 文件名 编辑方式查看，可以修改cat 文件名 显示全部文件内容more 文件名 分页显示文件内容less 文件名 与more相似 可以往前翻页tail 文件名 仅查看尾部 可以指定行数head 文件名 仅查看头部 可以指定行数 6.移动文件 改名 用哪个命令？mv改名 将文件test改为new mv test new1 mv将目录 /usr/men中的所有文件移到当前目录 mv /usr/men/*. 7.复制 删除文件复制 cp [-adfilprsu] 源文件(source) 目标文件(destination) 删除 rm [fir] 文件或目录 8.常用的通配符和含义“？”可替代单个字符。 ·“*”可替代任意多个字符。 ·方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC] 15. 用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)wc 命令 - c 统计字节数。 – l 统计行数。 - w 统计字数。 9.终止进程kill -9 pid 10.查找自己所在终端的信息who am i","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]}]}