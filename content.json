{"meta":{"title":"哦谢特谢特","subtitle":"苟利国家生死以","description":null,"author":"哦谢特谢特","url":"http://yoursite.com"},"pages":[{"title":"Linux","date":"2018-06-21T07:46:09.000Z","updated":"2018-06-21T07:46:09.000Z","comments":true,"path":"Linux/index.html","permalink":"http://yoursite.com/Linux/index.html","excerpt":"","text":""}],"posts":[{"title":"前端跨域问题的解决方案","slug":"前端跨域问题的解决方法","date":"2018-06-22T07:47:44.000Z","updated":"2018-06-22T08:02:42.000Z","comments":true,"path":"2018/06/22/前端跨域问题的解决方法/","link":"","permalink":"http://yoursite.com/2018/06/22/前端跨域问题的解决方法/","excerpt":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧 1.什么是跨域 域名 说明 是否跨域 http://www.a.com/a.js http://www.a.com/b.js 同一域名 否 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名文件夹不同 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名端口不同 是 http://www.a.com/a.js https://www.a.com/b.js 同一域名协议不同 是 http://www.a.com/a.js http://70.32.92.74/b.js 对应ip相同 是 http://www.a.com/a.js http://script.a.com/b.js 子域名不同 是 http://www.bilibili.com/a.js http://www.a.com/b.js 不同域名 是 2.解决方法1.JSONP实现跨域JSONP是json with padding（填充式json或参数式json）的简称","text":"近期在复习一些前端的知识，所以准备做一些前端问题知识总结，先来总结下跨域的问题吧 1.什么是跨域 域名 说明 是否跨域 http://www.a.com/a.js http://www.a.com/b.js 同一域名 否 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名文件夹不同 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名端口不同 是 http://www.a.com/a.js https://www.a.com/b.js 同一域名协议不同 是 http://www.a.com/a.js http://70.32.92.74/b.js 对应ip相同 是 http://www.a.com/a.js http://script.a.com/b.js 子域名不同 是 http://www.bilibili.com/a.js http://www.a.com/b.js 不同域名 是 2.解决方法1.JSONP实现跨域JSONP是json with padding（填充式json或参数式json）的简称JSONP包含两部分：回调函数和数据。 JSONP实现跨域请求的原理是动态创建&lt;script&gt;标签，然后利用&lt;script&gt;的src 不受同源策略约束来跨域获取数据1234567function handleResponse(response)&#123; console.log(response.data);&#125;var script = document.createElement('script');script.src = 'http:/www.domain.com/json?callback=handleResponse';document.body.insertBefore(script, document.body.firstChild);//handleResonse(&#123;\"data\": \"zhe\"&#125;) 具体流程：通过script标签请求时后台根据相应的参数(json,handleResponse)来生成相应的json数据(handleResponse({&quot;data&quot;: &quot;zhe&quot;}))，最后这个返回的json数据就会被放在当前js文件中被执行。 JSONP的缺陷：1、请求代码存在安全隐患。借助JSONP有可能进行跨站请求伪造(CSRF)攻击。2、无法确定jsonp成功与否3、只能实现get请求1234567$.ajax(&#123; url: 'http://www.domain.com/json', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;); 2.document.domain + iframe实现跨域这个方案只适用于主域名相同，子域名不同的跨域处理。 原理是通过js强制设置document.domain 为基础主域。 123456789101112//父窗口www.domain.com/a.html&lt;iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt;//子窗口child.domain.com/b.html&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 3.location.hash+iframe实现跨域原理是利用location.hash来进行传值。 假设域名a.com下的文件cs1.html要和domain.com域名下的cs2.html传递信息。1) cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向domain.com域名下的cs2.html页面2) cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据3) 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //先是a.com下的文件cs1.html文件：function startRequest()&#123; var ifr = document.createElement('iframe'); ifr.style.display = 'none'; ifr.src = 'http://www.domain.com/lab/cscript/cs2.html#paramdo'; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : ''; if (console.log) &#123; console.log('Now the data is '+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000);//cnblogs.com域名下的cs2.html://模拟一个简单的参数处理操作switch(location.hash)&#123; case '#paramdo': callBack(); break; case '#paramset': //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = 'somedata'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = 'http://a.com/test/cscript/cs3.html#somedata'; // 注意该文件在\"a.com\"域下 document.body.appendChild(ifrproxy); &#125;&#125;//a.com下的域名cs3.html//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 4. window.name + iframe实现跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 原理是通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//1.）a.html：(www.domain1.com/a.html)var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data);&#125;);//2.）proxy.html：(www.domain1.com/proxy....//中间代理页，与a.html同域，内容为空即可。//3.）b.html：(www.domain2.com/b.html)&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 5.postMessage实现跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 12345678910111213141516171819202122232425262728293031323334//1.）a.html：(www.domain1.com/a.html)&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt;//2.）b.html：(www.domain2.com/b.html)&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; 6.CORS（跨域资源共享）实现跨域CORS是通过一系列特殊的HTTP头来解决这一问题，这些http头信息可以允许双方判断请求成功或者失败 在发送跨域HTTP请求时，支持CORS的浏览器会引入额外的Origin头信息来指定请求的源。这个头信息需要包含三个部分——协议、域名和端口 服务端的工作是检查头信息是否接受该请求。如果请求被接受，那么需要返回一个包含Access-Control-Allow-Origin，其值与客户端Origin值相同的响应头 如果资源是公共的允许任何源发送请求，服务器可以返回一个通配符Access-Control-Allow-Origin: *如果匹配成功，那么浏览器将会继续处理这个请求，否则禁止该请求。123456789101112131415161718192021222324252627282930//1.）原生ajax// 前端设置是否带cookiexhr.withCredentials = true;示例代码：var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;;//2.）jQuery ajax$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); java中后台可以这样设置12345 //导入包：import javax.servlet.http.HttpServletResponse; //接口参数中定义：HttpServletResponse responseresponse.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\"); // 若有端口需写全（协议+域名+端口）response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); 7.Nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 配置信息：123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 前端代码12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); node.js后台 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 8.Web Sockets实现跨域web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。 12345var socket = new WebSockt('ws://www.domain.com');//http-&gt;ws; https-&gt;wsssocket.send('hello WebSockt');socket.onmessage = function(event)&#123; var data = event.data;&#125; 参考资料阮一峰大佬的CORS 详解","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"web性能优化","slug":"Web性能优化","date":"2018-06-21T15:47:44.000Z","updated":"2018-06-22T02:09:34.000Z","comments":true,"path":"2018/06/21/Web性能优化/","link":"","permalink":"http://yoursite.com/2018/06/21/Web性能优化/","excerpt":"Web性能优化1、 减少http请求a) 在浏览器和服务器发生通信的时候 就已经消耗了大量的时间b) 网速相同的条件下 下载一个100kb的图片比下载两个50kb的图片要快c) 减少http请求的主要手段是合并css 合并JavaScript 合并图片","text":"Web性能优化1、 减少http请求a) 在浏览器和服务器发生通信的时候 就已经消耗了大量的时间b) 网速相同的条件下 下载一个100kb的图片比下载两个50kb的图片要快c) 减少http请求的主要手段是合并css 合并JavaScript 合并图片 2、 使用浏览器缓存a) 一个网站中 css js logo 图标这些静态资源文件更新的频率都比较低 如果将这些文件缓存在浏览器中可以极好地改善型性能b) 通过设置http头中的cache-control和expires属性 可以设定浏览器缓存c) 在某些时候 静态资源文件变化需要及时应用到客户端浏览器 这种情况 可以通过改变文件名称实现 即更新js文件不是更新js文件内容d) 使用留恋其缓存策略的网站在更新静态资源时 应采用分批次更新的方法 比如需要更新10个图标文件 不宜把10个文件一次全部更新 应该一个文件一个文件逐步更新 并有一定的间隔时间 以免浏览器突然大量缓存失效 3、 服务端启用压缩4、 css放在页面最上面 js放在页面最下面a) 浏览器会在下载完全部css之后才对整个页面进行渲染 因此最好的做法是将css放在页面最上面 让浏览器尽快下载cssb) Js则相反 浏览器在加载js后立即执行 有可能会阻塞整个页面 造成页面显示缓慢 因此js最好放在页面最下面 但如果解析页面的时候就需要用到js 这里就不适合放在底部了 5、 精简css和js文件a) css和js压缩 减少下载的文件体积 常用的方式是使用 yui compressor 它的特点是：移除注释 移除额外的空格 细微的优化 标识符替换b) 压缩js java -jar yuicompressor-2.4.2.jar api.js&gt;api.min.js 压缩css java -jar yuicompressor-2.4.2.jar style.css&gt;style.min.css 6、 减少对dom的操作a) 对dom操作的代价是高昂的b) 修改和访问dom元素会造成页面的重绘和重排 造成重绘重排的原因i. 修改domii. 修改样式表iii. 用户事件c) 网页生成的过程大致可以分为五个步骤i. html转换成domii. css代码转换成cssomiii. 结合dom和cssom 生成一棵渲染树iv. 生成布局 即将所有渲染树的所有节点进行平面合成v. 将布局绘制在屏幕上 7、 使用json格式进行数据交换8、 减少cookie传输a) 因为cookie是本地的磁盘文件 每次浏览器都会去读取相应的cookie所以建议去除不必要的cookie 使cookie体积尽量小 9、 使用cdn加速a) cdn全称是content delivery network 即内容分发网络b) cdn本质仍然是一个缓存 而且将数据缓存在离用户最近的地方 使用户最快的获取数据c) cdn能够缓存的一般般是静态资源 如图片 文件 css script脚本 静态网页d) 实时性不好使cdn的缺陷","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"linux中常见的指令","slug":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？","date":"2018-06-21T12:47:44.000Z","updated":"2018-06-21T14:31:14.000Z","comments":true,"path":"2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","link":"","permalink":"http://yoursite.com/2018/06/21/1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？/","excerpt":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？ 查看当前进程：ps 查看负载情况：free 查看内存的使用情况 top 动态显示cpu的负载情况 执行退出：exit 查看当前路径：pwd","text":"1. 怎么查看当前进程 负载情况？怎么执行退出？怎么查看当前路径？ 查看当前进程：ps 查看负载情况：free 查看内存的使用情况 top 动态显示cpu的负载情况 执行退出：exit 查看当前路径：pwd 2.如何清屏？怎么退出当前命令？怎么执行s会面？ 清屏：clear 退出当前：ctrl+c 执行睡眠：ctrl+z fg恢复后台 3.ls命令执行什么功能？可以带哪些参数？ ls执行的功能：列出指定目录中的目录，以及文件 有哪些参数：a所有文件 l详细信息，包括大小写字节数，可读可写，可执行的权限等 4.目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？创建目录：mkdir创建文件：典型的如touch vi复制文件：cp 5.查看文件内容的命令有哪些？vi 文件名 编辑方式查看，可以修改cat 文件名 显示全部文件内容more 文件名 分页显示文件内容less 文件名 与more相似 可以往前翻页tail 文件名 仅查看尾部 可以指定行数head 文件名 仅查看头部 可以指定行数 6.移动文件 改名 用哪个命令？mv改名 将文件test改为new mv test new1 mv将目录 /usr/men中的所有文件移到当前目录 mv /usr/men/*. 7.复制 删除文件复制 cp [-adfilprsu] 源文件(source) 目标文件(destination) 删除 rm [fir] 文件或目录 8.常用的通配符和含义“？”可替代单个字符。 ·“*”可替代任意多个字符。 ·方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC] 15. 用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)wc 命令 - c 统计字节数。 – l 统计行数。 - w 统计字数。 9.终止进程kill -9 pid 10.查找自己所在终端的信息who am i","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"欢迎来到我的尬乐底master","slug":"hello-world","date":"2018-06-21T02:21:30.000Z","updated":"2018-06-21T12:24:12.000Z","comments":true,"path":"2018/06/21/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/21/hello-world/","excerpt":"","text":"庆祝今天博客刚刚搭建成功！！！","categories":[],"tags":[]}]}